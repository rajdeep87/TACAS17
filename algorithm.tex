\section{Abstract Conflict Driven Clause Learning}
%
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{decide}{Decide}
\SetKwFunction{deduce}{deduce}
\SetKwFunction{backtrack}{backtrack}
\SetKwFunction{print}{print}
\SetKw{return}{return}
\SetKwFunction{nondet}{nondet}
\SetKwFunction{run}{run}
\SetKwFunction{learn}{learn}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwRepeat{Do}{do}{while}
%\SetKwFunction{assume}{assume}
%\SetKwFunction{isf}{isFeasible}
\SetKwData{conflict}{conflict}
\SetKwData{safe}{safe}
\SetKwData{sat}{sat}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{%An abstract domain $A$, 
A program $\mathcal{S}$, a
  propagation heuristics $H$, a decision heuristics $\mathit{decide}$,
and a conflict analysis heuristics $\mathit{conflict\_analysis}$.}
\Output{The status \safe or \unsafe, and a counterexample if \unsafe.}
$\mathcal{T} \leftarrow \langle\rangle$ \;
$\mathcal{R} \leftarrow \emptyset$ \;
$\mathit{result} \leftarrow \mathit{deduce}(S,\mathcal{T},\mathcal{R}, H)$ \;
\lIf{$\mathit{result}$ = \conflict} {
  \return \safe}
\While{$true$} 
{
\lIf{$\mathit{result}$ = \sat} {
  \return \unsafe}
  $d \leftarrow \mathit{decide}(\mathit{abs}(\mathcal{T}))$ \;
%  $v \leftarrow v \meet d$ \; 
  $\mathcal{T} \leftarrow \mathcal{T} \cdot d$ \; 
  $\mathcal{R}[|\mathcal{T}|] \leftarrow $\textsf{decision} \;
  $\mathit{result} \leftarrow \mathit{deduce}(\mathcal{S},\mathcal{T},\mathcal{R})$\;
  \Do{$\mathit{result} = \conflict$} {
%    learn() \;
    \lIf{$\neg \mathit{conflict\_analysis}(\mathcal{S},\mathcal{T},\mathcal{R})$} {
      \return \safe
    }
    $\mathit{result} \leftarrow \mathit{deduce}(\mathcal{S},\mathcal{T},\mathcal{R})$ \;
  }
}
\end{small}
\caption{Abstract Conflict Driven Clause Learning $ACDCL(A)$ \label{Alg:acdcl}}
\end{algorithm2e}
%
%\subsection{Algorithm for Abstract Conflict Driven Clause Learning}
Algorithm~\ref{Alg:acdcl} presents an overview of the ACDCL algorithm.
The algorithm begins with a set $S$ of abstract deduction transformer 
$\widehat{ded_{\varphi}}$ \pscmt{define in terms of P and A} for a formula $\varphi$ over an abstract 
domain $A$, an abstract valuation $\langle v \leftarrow \top \rangle$, 
and an empty propagation trail and reason trail, $\mathcal{T}$, $\mathcal{R}$, 
respectively.  The propagation trail stores all meet irreducibles inferred 
by the abstract model search phase (deductions and decisions), while the 
reason trail maps elements of propagation trail to transformers that were 
used to derive them. A propagation trail is mapped to an abstract value as 
follows; $\mathit{abs}(\mathcal{T})=\bigsqcap_{m \in \mathcal{T}}m$ with 
$\mathit{abs}(\mathcal{T})=\top$ if $\mathcal{T}$ is the empty sequence $\langle\rangle$.

The procedure $deduce(S,v,\mathcal{T},\mathcal{R})$ computes a greatest 
fixed point over the transformers in $\varphi$ that refines the abstract valuation 
$v$, similar to the BCP step in SAT solvers.  If the result of $deduce$ 
returns \textsf{conflict} ($\bot$), the algorithm terminates with \textsf{safe}. 
Else, the analysis enters into the while($true$) loop and makes a new decision 
by a call to $decide(v)$ which returns a new meet irreducible $d$ that is
consistent to the state of the solver. \pscmt{why do we have to store $v$ and $\mathcal{T}$?} If $d$ refines the current abstract 
value $v$, the corresponding propagation and reason trail, $\mathcal{T}$ 
and $\mathcal{R}$ are updated. 

For example, a decision in the interval domain restricts the range of 
intervals for variables.
% so the analysis jumps under a 
%greatest fixed-point \pscmt{???}. Note that the widening operation in abstract interpretation 
%jumps above a least fixed-point, so decisions can be viewed as 
%{\em dual widening} \pscmt{what do we learn?}.  
The procedure $deduce$ is called next to infer a new 
set of meet irreducibles for the current decision.  The model search phase 
alternates between the decision and deduction until the abstract value $v$ 
precisely \pscmt{not true} represents the set of models or the deduction leads to a \textsf{conflict}.  
Checking whether the abstract model $v$ concretises to a set of models of $\varphi$; this corresponds to a 
$\gamma$-completeness~\cite{dhk2013-popl} check in abstract interpretation.  
If $v$ is $\gamma$-complete, then it cannot be refined further.  Thus, the 
algorithm returns the abstract model $v$, which is a set of concrete models, and terminates with \textsf{unsafe} or the 
current abstraction is insufficient to determine the satisfiability of $\varphi$.  
However, in case of \textsf{conflict}, the algorithm enters in the 
$\mathit{conflict\_analysis}$ phase to learn the reason for the conflict.  
There can be multiple incomparable reasons for conflict -- based on 
the choice of Unique Implication Point (UIP)~\cite{cdcl}.  ACDCL heuristically 
chooses one reason.  A learnt clause must include asserting cuts which 
guarantees derivation of new meet irreducibles after backtracking. The clause 
learning and backtracking continues as long as the result of deduction 
is conflicting ($\bot$), that is, the abstract valuation $v$ does not
abstractly satisfy the formula \pscmt{define}.  If no further backtrack is possible, 
then the algorithm terminates and $\varphi$ is \textsf{safe}. Else, the 
algorithm makes a new decision and the above process is repeated 
until a real counterexample \pscmt{is this a model?} is obtained or the algorithm backtracks to 
decision level 0 after a conflict in which case it returns \textsf{safe}. 

\paragraph{Solver State.}  The state of a ACDCL solver is a tuple 
of the form $\langle \mathcal{E}, S \rangle$.  Here, $\mathcal{E}$ 
is a sequence of labelled information of the form $(m,s)$ where 
$m$ is a meet irreducible and $s = \mathsf{decision}$ if $m$ is a decision, 
or $s = \mathsf{deduction}$ if $m$ is inferred by a deduction. And $S$ is 
a set of abstract deduction transformer \pscmt{???}.  A trail in a SAT solver 
stores variable assignments of the form $(p, t)$, where $p$ is 
a propositional variable that appears at most once in the trail 
and $t$ is a truth assignment (true or false).  Whereas, a trail 
$\mathcal{T}$ in ACDCL contains a sequence of meet irreducibles 
inferred by deduction or decision phase where a variable in trail 
can be assigned \pscmt{constrained?} multiple times, each time with increasingly precise 
bounds \pscmt{that's specific for a particular domain}.  A current valuation $v$ is a meet of all elements of trail
$\mathcal{T}$, such that $v = \top$ when $\mathcal{T}$ is 
empty or $v=\underset{i \geq 0 \wedge i \leq |\mathcal{T}|}{\meet m_i}$, where 
$m_i \in \mathcal{T}$.  A solver is in conflict if some clauses in
$\mathcal{S}$ is not abstractly satisfied by $v$.

%\pscmt{define ``consistent with trail''}
