\section{Abstract Conflict Driven Clause Learning}
%
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{decide}{Decide}
\SetKwFunction{deduce}{deduce}
\SetKwFunction{backtrack}{backtrack}
\SetKwFunction{print}{print}
\SetKw{return}{return}
\SetKwFunction{nondet}{nondet}
\SetKwFunction{run}{run}
\SetKwFunction{learn}{learn}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwRepeat{Do}{do}{while}
%\SetKwFunction{assume}{assume}
%\SetKwFunction{isf}{isFeasible}
\SetKwData{conflict}{conflict}
\SetKwData{safe}{safe}
\SetKwData{sat}{sat}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{%An abstract domain $A$, 
A program $\mathcal{S}$, a
  propagation heuristics $H$, a decision heuristics $\mathit{decide}$,
and a conflict analysis heuristics $\mathit{conflict\_analysis}$.\rmcmt{calling
them heuristics is not a good idea since these are key phases of the cdcl
algorithm. Each phase may have a heuristics for some sub phase but the algorithm
of each phase still remians a procedure and not a heuristic}}
\Output{The status \safe or \unsafe, and a counterexample if \unsafe.}
$\mathcal{T} \leftarrow \langle\rangle$ \;
$\mathcal{R} \leftarrow \emptyset$ \;
$\mathit{result} \leftarrow \mathit{deduce}(S,\mathcal{T},\mathcal{R}, H)$ \;
\lIf{$\mathit{result}$ = \conflict} {
  \return \safe}
\While{$true$} 
{
\lIf{$\mathit{result}$ = \sat} {
  \return \unsafe}
  $d \leftarrow \mathit{decide}(\mathit{abs}(\mathcal{T}))$ \;
%  $v \leftarrow v \meet d$ \; 
  $\mathcal{T} \leftarrow \mathcal{T} \cdot d$ \; 
  $\mathcal{R}[|\mathcal{T}|] \leftarrow $\textsf{decision} \;
  $\mathit{result} \leftarrow \mathit{deduce}(\mathcal{S},\mathcal{T},\mathcal{R})$\;
  \Do{$\mathit{result} = \conflict$} {
%    learn() \;
    \lIf{$\neg \mathit{conflict\_analysis}(\mathcal{S},\mathcal{T},\mathcal{R})$} {
      \return \safe
    }
    $\mathit{result} \leftarrow \mathit{deduce}(\mathcal{S},\mathcal{T},\mathcal{R})$ \;
  }
}
\end{small}
\caption{Abstract Conflict Driven Clause Learning $ACDCL(A)$ \label{Alg:acdcl}}
\end{algorithm2e}
%
%\subsection{Algorithm for Abstract Conflict Driven Clause Learning}
Algorithm~\ref{Alg:acdcl} presents an overview of the ACDCL algorithm.
The algorithm takes a program \pscmt{make this a set of transformers
  (parametrised by the propagation heuristics)}
$\mathcal{S}$ and propagation, decision, and conflict analysis
heuristics as inputs.  
\rmcmt{Approximation of the concrete transformers in 
$\mathcal{S}$ are typically available in abstract domain in the 
form of strongest-post condition or weakest pre-condition. } 
As internal state, it maintains a propagation
trail $\mathcal{T}$ and a reason trail \pscmt{map?} $\mathcal{R}$.
The propagation trail is an initially empty sequence of meet
irreducibles inferred by the abstract model search phase (deductions
and decisions). The reason trail maps \pscmt{certain?} elements of the
propagation trail to transformers $s\in\mathcal{S}$ that were used to
derive them. The \emph{abstract value} $\mathit{abs}(\mathcal{T})$
corresponding to the propagation trail $\mathcal{T}$ is the
conjunction of the meet irreducibles on the trail:
$\mathit{abs}(\mathcal{T})=\bigsqcap_{m \in \mathcal{T}}m$ with
$\mathit{abs}(\mathcal{T})=\top$ if $\mathcal{T}$ is the empty
sequence $\langle\rangle$.

The procedure $deduce$ computes a greatest fixed point over the
transformers in $\mathcal{S}$ that refines the abstract value,
similar to the BCP step in SAT solvers.  If the result of $deduce$
returns \textsf{conflict} ($\bot$), the algorithm terminates with
\textsf{safe}.  Else, the analysis enters into the while($true$) loop
and makes a new decision by a call to $\mathit{decide}$ which returns
a new meet irreducible $d$ that is consistent with the state of the
solver. \pscmt{what happens if we cannot make any decision any more?
  -- then we should either have deduced $\bot$ or
  $\mathit{abs}(\mathcal{T})$ must be $\gamma$-complete} If $d$
refines the current abstract value, the corresponding propagation
and reason trail, $\mathcal{T}$ and $\mathcal{R}$ are updated.
%
For example, a decision in the interval domain restricts the range of 
intervals for variables.
% so the analysis jumps under a 
%greatest fixed-point \pscmt{???}. Note that the widening operation in abstract interpretation 
%jumps above a least fixed-point, so decisions can be viewed as 
%{\em dual widening} \pscmt{what do we learn?}.  

The procedure $\mathit{deduce}$ is called next to infer new meet
irreducibles taking into account the current decision.  The model search phase
alternates between the decision and deduction until $\mathit{deduce}$
returns either \textsf{sat} or \textsf{conflict}.
In the former case, we have found an abstract value that represents 
models of $\varphi$ and thus we return \textsf{unsafe}.
%
% has found an abstract value that represents a set of models of $\varphi$ or the
% deduction leads to a \textsf{conflict}.  Checking whether the abstract
% model concretises to a set of models of $\varphi$; this
% corresponds to a $\gamma$-completeness~\cite{dhk2013-popl} check in
% abstract interpretation.  If $v$ is $\gamma$-complete, then it cannot
% be refined further.  Thus, the algorithm returns the abstract model
% $v$, which is a set of concrete models, and terminates with
% \textsf{unsafe} or the current abstraction is insufficient to
% determine the satisfiability of $\varphi$.  

In the latter case the algorithm enters in the
$\mathit{conflict\_analysis}$ phase to learn the reason for the
conflict.  There can be multiple incomparable reasons for conflict --
based on the choice of Unique Implication Point (UIP)~\cite{cdcl}.
ACDCL heuristically chooses one reason.  A learnt clause must include
asserting cuts which guarantees derivation of new meet irreducibles
after backtracking. The clause learning and backtracking continues as
long as the result of deduction is conflicting ($\bot$), that is, the
abstract valuation $v$ does not abstractly satisfy the formula
\pscmt{define}.  If no further backtrack is possible, then the
algorithm terminates and $\varphi$ is \textsf{safe}. Else, the
algorithm makes a new decision and the above process is repeated until
a real counterexample \pscmt{is this a model?} is obtained or the
algorithm backtracks to decision level 0 after a conflict in which
case it returns \textsf{safe}.

\paragraph{Solver State.}  \pscmt{This paragraph seems redundant. Doesn't this redefine $\mathcal{T}$?} The state of a ACDCL solver is a tuple 
of the form $\langle \mathcal{E}, S \rangle$.  Here, $\mathcal{E}$ 
is a sequence of labelled information of the form $(m,s)$ where 
$m$ is a meet irreducible and $s = \mathsf{decision}$ if $m$ is a decision, 
or $s = \mathsf{deduction}$ if $m$ is inferred by a deduction. And $S$ is 
a set of abstract deduction transformer \pscmt{???}.  A trail in a SAT solver 
stores variable assignments of the form $(p, t)$, where $p$ is 
a propositional variable that appears at most once in the trail 
and $t$ is a truth assignment (true or false).  Whereas, a trail 
$\mathcal{T}$ in ACDCL contains a sequence of meet irreducibles 
inferred by deduction or decision phase where a variable in trail 
can be assigned \pscmt{constrained?} multiple times, each time with increasingly precise 
bounds \pscmt{that's specific for a particular domain}.  
\rmcmt{define trail refinement}
\Omit {
A current valuation $v$ is a meet of all elements of trail
$\mathcal{T}$, such that $v = \top$ when $\mathcal{T}$ is 
empty or $v=\underset{i \geq 0 \wedge i \leq |\mathcal{T}|}{\meet m_i}$, where 
$m_i \in \mathcal{T}$.  A solver is in conflict if some clauses in
$\mathcal{S}$ is not abstractly satisfied by $v$.
}
%\pscmt{define ``consistent with trail''}
