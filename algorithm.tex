\section{Abstract Conflict Driven Clause Learning}
In a typical abstract interpretation based galois-connection settings over 
an over-approximate domain, every concrete elements have a unique over-approximate 
representation in the abstract.  Likewise, every concrete transformer is
over-approximated by a unique abstract transformer.  We now define a abstract 
deduction transformer.  

\begin{definition}{(Abstract Deduction Transformer)} An abstract deduction
transformer, $\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$ is a sound approximation of a concrete model transformer
$ded_{\varphi}$, given by $\widehat{ded_{\varphi}} : A \rightarrow A$, such that 
$\forall a \in A: \widehat{ded_{\varphi}}(a) \in \{\top, \bot, m\}$, where 
$m \in A$ is a meet irreducible.   
\end{definition}

Let us consider a formula $\varphi = (x:=y-1)$ to be analyzed over 
an interval abstract domain, $A = ItvDom$, and let $a = \langle y:[3, 5]
\rangle \in ItvDom$, then $\widehat{ded_{\varphi}}(a) = a \meet \langle x:[2, 4]
\rangle$.  An abstract deduction transformer is typically computed in the form 
of strongest post-condition or a weakest pre-condition of a formula in the 
abstract domain.  

A meet decomposition of the outcome of abstract deduction transformer 
is obtained by taking a meet of the element $\langle y:[3, 5] \rangle, 
\langle x:[2, 4] \rangle \in ItvDom$ which gives set of meet irreducibles, 
$\{ \langle y \succeq 3 \rangle, \langle y \preceq 5 \rangle, 
\langle x \succeq 2 \rangle, \langle x \preceq 4 \rangle \}$, that are 
precisely complementable.

\begin{definition}{(Meet Decomposition)} A meet decomposition of an abstract
element $a \in A$ is a set of meet irreducibles $M \subseteq A$ such that 
$\forall m_i \in M, \meet(m_i) = a$, where $max(i) = |M|$.
\end{definition}
 
For a program with $N$ variables, let $L$ be the total number of 
meet irreducibles returned by a domain $D$.  For $D$ = {\em ItvDom}, the 
maximum value of $L$ is $2*N$, whereas the maximum value of $L$ is 
$2*(N^2)$ for $D$ = {\em OctDom}. Note that an octagon is the conjunction 
of all octagonal inequalities in the set $L$.
%\rmcmt{safety as satisfiability}
%
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{decide}{Decide}
\SetKwFunction{deduce}{deduce}
\SetKwFunction{backtrack}{backtrack}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{nondet}{nondet}
\SetKwFunction{run}{run}
\SetKwFunction{learn}{learn}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwRepeat{Do}{do}{while}
%\SetKwFunction{assume}{assume}
%\SetKwFunction{isf}{isFeasible}
\SetKwData{conflict}{CONFLICT}
\SetKwData{safe}{safe}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of abstract deduction transformer, 
$\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract domain $A$}
\Output{The status (\safe or \unsafe) and a counterexample if \unsafe}
$v \leftarrow \top$ \;
$\mathcal{T} \leftarrow \epsilon$ \;
$\mathcal{R} \leftarrow \emptyset$ \;
$result \leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$ \;
\uIf{$result$ == \conflict} {
  \return \safe \;
}
\While{$true$} 
{
  \uIf{$v$ is $\gamma$-complete} {
    \return \unsafe;
  }
  $d \leftarrow decide(v)$ \;
  $v \leftarrow v \meet d$ \; 
  $\mathcal{T} \leftarrow \mathcal{T} . d$ \; 
  $\mathcal{R}[|\mathcal{T}|] \leftarrow nil$ \;
  $result \leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$\;
  \Do{$result == \conflict$} {
    learn() \;
    \uIf{$\neg$ conflict\_analysis()} {
      return \safe \;  
    }
    result $\leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$ \;
  }
}
\end{small}
\caption{Abstract Conflict Driven Clause Learning $\{ACDCL(S)\}$ \label{Alg:acdcl}}
\end{algorithm2e}
%
\Omit {
Static program analysis based on abstract
interpretation~\cite{DBLP:conf/emsoft/Cousot07} has been widely used to
verify certain classes of properties for safety-critical systems.  In
abstract interpretation, a given program is analysed with respect to a set
of given abstract domains.  However, ACDCL is a novel program analysis 
technique that embeds an abstract domain inside the CDCL algorithm.
From the abstract interpretation point of view, ACDCL is an abstract 
interpreter that uses decision and learning to increase transformer precision. 
From the decision procedure perspective, ACDCL is a SAT solver for program 
analysis constraints and is thus a strict generalisation of propositional CDCL solvers.
Constraint propagation in ACDCL uses fixed point iteration, decisions restrict the 
range of intervals and learning generates program analysis constraints (not assumptions) 
that preserve the error reachability.  Moreover, ACDCL implicitly 
perform program and property driven trace partitioning to increase the precision
of the analysis.  
}
Algorithm~\ref{Alg:acdcl} presents an overview of the ACDCL algorithm.
Given a \rmcmt{formula (F)} and an abstract valuation $v = \top$,  
ACDCL returns {\em safe} if $F$ is unsatisfiable and P is safe. Else, 
ACDCL returns a model that satisfies $F$ and P is {\em unsafe}.  The 
procedure $deduce(P)$ is similar to BCP step in SAT solvers where 
it computes least fix-point with strongest post-condition using 
forward analysis. If the result of $deduce(P)$ 
is BOTTOM ($\perp$), the algorithm terminates with {\em safe}. Else, the 
{\em gamma completeness} check~\cite{sas01} is performed to determine if it is a 
real counterexample. If the {\em gamma completeness} check is successful, then the 
counterexample is real. Else, the algorithm enters into the while($true$)
loop and heuristically picks a meet irreducible for decision. For example, assuming 
interval domain, decisions restrict the range of intervals for variables, so the analysis jumps under a 
greatest fixed-point. Note that the widening operation in abstract interpretation 
jumps above a least fixed-point, so decisions can be viewed as 
dual widening. The procedure $deduce(P)$ is called next to deduce new facts for 
current decision. The algorithm terminates with {\em unsafe} if the result of $deduce(P)$ 
is {\em gamma complete}. Else, the algorithm enters in to $conflict\_analysis()$ phase to learn 
the reason for {\em conflict}. There can be multiple incomparable reasons for conflict --
based on the choice of Unique Implication Point (UIP), ACDCL heuristically choose one. 
A learnt clause must include asserting cuts which guarantees
derivation of new information after backtracking. The clause learning and backtracking continues 
as long as the result of deduction is BOTTOM ($\perp$) or the 
analysis backtracks to decision level 0. If no further backtrack is possible, then the 
algorithm terminates with {\em safe}. Else, the algorithm makes a new decision and 
the above process is repeated until a real counterexample is obtained or the algorithm 
backtracks to decision level 0 after a conflict in which case it returns {\em safe}. 
Currently, ACDCL handles loops in the program by unrolling the bounded loops. 
However, we are developing a new technique for automatic invariant generation using 
ACDCL for unbounded proofs. 


A decision is made by calling a procedure $decide(v)$ which 
returns a meet irreducible $d$.  If $d$ refines the 
current abstract value $v$, then the worklist is updated with 
all transformers that are dependant on the current decision 
$d$ along with the update of the corresponding propagation 
and reason trail, $\mathcal{T}$ and $\mathcal{R}$. 
