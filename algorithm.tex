\section{Abstract Conflict Driven Clause Learning}
%
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{decide}{Decide}
\SetKwFunction{deduce}{deduce}
\SetKwFunction{backtrack}{backtrack}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{nondet}{nondet}
\SetKwFunction{run}{run}
\SetKwFunction{learn}{learn}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwRepeat{Do}{do}{while}
%\SetKwFunction{assume}{assume}
%\SetKwFunction{isf}{isFeasible}
\SetKwData{conflict}{CONFLICT}
\SetKwData{safe}{safe}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of abstract deduction transformer, 
$\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract domain $A$}
\Output{The status (\safe or \unsafe) and a counterexample if \unsafe}
$v \leftarrow \top$ \;
$\mathcal{T} \leftarrow \epsilon$ \;
$\mathcal{R} \leftarrow \emptyset$ \;
$result \leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$ \;
\uIf{$result$ == \conflict} {
  \return \safe \;
}
\While{$true$} 
{
  \uIf{$v$ is $\gamma$-complete} {
    \return \unsafe;
  }
  $d \leftarrow decide(v)$ \;
  $v \leftarrow v \meet d$ \; 
  $\mathcal{T} \leftarrow \mathcal{T} . d$ \; 
  $\mathcal{R}[|\mathcal{T}|] \leftarrow nil$ \;
  $result \leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$\;
  \Do{$result == \conflict$} {
    learn() \;
    \uIf{$\neg$ conflict\_analysis()} {
      return \safe \;  
    }
    result $\leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$ \;
  }
}
\end{small}
\caption{Abstract Conflict Driven Clause Learning $\langle ACDCL(S) \rangle$ \label{Alg:acdcl}}
\end{algorithm2e}
%
%\subsection{Algorithm for Abstract Conflict Driven Clause Learning}
Algorithm~\ref{Alg:acdcl} presents an overview of the ACDCL algorithm.
The algorithm begins with a set $S$ of abstract deduction transformer 
$\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$, an abstract valuation $\langle v \leftarrow \top \rangle$, 
and an empty propagation trail and reason trail, $\mathcal{T}$, $\mathcal{R}$, 
respectively.  The propagation trail stores all meet irreducibles inferred 
by the abstact model search phase (deductions and decisions), while the 
reason trail maps elements of propagation trail to transformers that were 
used to derive them.  

The procedure $deduce(S,v,\mathcal{T},\mathcal{R})$ computes a greatest 
fixed point over the transformers in F that refines the abstract valuation 
$v$, similar to BCP step in SAT solvers.  If the result of $deduce$ 
returns {\em CONFLICT} ($\perp$), the algorithm terminates with {\em safe}. 
Else, the analysis enters into the while($true$) loop and makes a new decision 
by a call to $decide(v)$ which returns a new meet irreducible $d$ that is
consistent to the state of the solver.  If $d$ refines the current abstract 
value $v$, the corresponding propagation and reason trail, $\mathcal{T}$ 
and $\mathcal{R}$ are updated. 

For example, a decision in interval domain restrict the range of 
intervals for variables, so the analysis jumps under a 
greatest fixed-point. Note that the widening operation in abstract interpretation 
jumps above a least fixed-point, so decisions can be viewed as 
{\em dual widening}.  The procedure $deduce$ is called next to infer new 
set of meet irreducibles for the current decision.  The model search phase 
alternates between the decision and deduction until the result of deduction 
is either $\gamma$-complete~\cite{gamma} or the deduction leads to a {\em CONFLICT}.  
If $v$ is $\gamma$-complete, then it cannot be refined further.  Thus, the 
algorithm returns the error trace $v$ and terminates with UNSAFE or the 
current abstraction is insufficient to determine the satisfiability of $\varphi$.  
However, in case of {\em CONFLICT}, the algorithm enters in to 
$conflict\_analysis()$ phase to learn the reason for {\em conflict}.  
There can be multiple incomparable reasons for conflict -- based on 
the choice of Unique Implication Point (UIP)~\cite{cdcl}.  ACDCL heuristically 
choose one reason.  A learnt clause must include asserting cuts which 
guarantees derivation of new meet irreducibles after backtracking. The clause 
learning and backtracking continues as long as the result of deduction 
is conflicting ($\perp$), that is, the abstract valuation $v$ does not
abstractly satisfy the formula.  If no further backtrack is possible, 
then the algorithm terminates and $\varphi$ is {\em SAFE}. Else, the 
algorithm makes a new decision and the above process is repeated 
until a real counterexample is obtained or the algorithm backtracks to 
decision level 0 after a conflict in which case it returns {\em SAFE}. 

\paragraph \em{Solver State:}  The state of a ACDCL solver is a tuple 
of the form $\langle \mathcal{E}, S \rangle$.  Here, $\mathcal{E}$ 
is a sequence of labelled information of the form $(m,s)$ where 
$m$ is a meet irreducible and $s = decision$ if $m$ is a decision, 
or $s = deduction$ if $m$ is inferred by a deduction. And $S$ is 
a set of abstract deduction transformer.  A trail in SAT solver 
stores variable assignments of the form $(p, t)$, where $p$ is 
a propositional variable that appears at most once in the trail 
and $t$ is a truth assignment (true or false).  Whereas, a trail 
$\mathcal{T}$ in ACDCL contains a sequence of meet irreducibles 
inferred by deduction or decision phase where a variable in trail 
can be assigned multiple times, each time with increasingly precise 
bounds.  A current valuation $v$ is a meet of all elements of trail
$\mathcal{T}$, such that $v = \top$ when $\mathcal{T}$ is 
empty or $v=\underset{i \geq 0 \wedge i \leq |\mathcal{T}|}{\meet m_i}$, where 
$m_i \in \mathcal{T}$.  A solver is in {\em conflict} if some clauses in
$\mathcal{S}$ is not abstractly satisfied by $v$.
