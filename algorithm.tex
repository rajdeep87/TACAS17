\section{Abstract Conflict Driven Clause Learning}
In a typical abstract interpretation based galois-connection settings over 
an over-approximate domain, every concrete elements have a unique over-approximate 
representation in the abstract.  Likewise, every concrete transformer is
over-approximated by a unique abstract transformer.  We now define a abstract 
deduction transformer.  

\begin{definition}{(Abstract Deduction Transformer)} An abstract deduction
transformer, $\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$ is a sound approximation of a concrete model transformer
$ded_{\varphi}$, given by $\widehat{ded_{\varphi}} : A \rightarrow A$, such that 
$\forall a \in A: \widehat{ded_{\varphi}}(a) \in \{\top, \bot, m\}$, where 
$m \in A$ is a meet irreducible.   
\end{definition}

Let us consider a formula $\varphi = (x:=y-1)$ to be analyzed over 
an interval abstract domain, $A = ItvDom$, and let $a = \langle y:[3, 5]
\rangle \in ItvDom$, then $\widehat{ded_{\varphi}}(a) = a \meet \langle x:[2, 4]
\rangle$.  An abstract deduction transformer is typically computed in the form 
of strongest post-condition or a weakest pre-condition of a formula in the 
abstract domain.  

A meet decomposition of the outcome of abstract deduction transformer 
is obtained by taking a meet of the element $\langle y:[3, 5] \rangle, 
\langle x:[2, 4] \rangle \in ItvDom$ which gives set of meet irreducibles, 
$\{ \langle y \succeq 3 \rangle, \langle y \preceq 5 \rangle, 
\langle x \succeq 2 \rangle, \langle x \preceq 4 \rangle \}$, that are 
precisely complementable.

\begin{definition}{(Meet Decomposition)} A meet decomposition of an abstract
element $a \in A$ is a set of meet irreducibles $M \subseteq A$ such that 
$\forall m_i \in M, \meet(m_i) = a$, where $max(i) = |M|$.
\end{definition}
 
For a program with $N$ variables, let $L$ be the total number of 
meet irreducibles returned by a domain $D$.  For $D$ = {\em ItvDom}, the 
maximum value of $L$ is $2*N$, whereas the maximum value of $L$ is 
$2*(N^2)$ for $D$ = {\em OctDom}. Note that an octagon is the conjunction 
of all octagonal inequalities in the set $L$.
%\rmcmt{safety as satisfiability}
\subsection{Static Analyses Equations for Safety}
Currently, ACDCL handles loops in the program by unrolling the bounded loops. 
%
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{decide}{Decide}
\SetKwFunction{deduce}{deduce}
\SetKwFunction{backtrack}{backtrack}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{nondet}{nondet}
\SetKwFunction{run}{run}
\SetKwFunction{learn}{learn}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwRepeat{Do}{do}{while}
%\SetKwFunction{assume}{assume}
%\SetKwFunction{isf}{isFeasible}
\SetKwData{conflict}{CONFLICT}
\SetKwData{safe}{safe}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of abstract deduction transformer, 
$\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract domain $A$}
\Output{The status (\safe or \unsafe) and a counterexample if \unsafe}
$v \leftarrow \top$ \;
$\mathcal{T} \leftarrow \epsilon$ \;
$\mathcal{R} \leftarrow \emptyset$ \;
$result \leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$ \;
\uIf{$result$ == \conflict} {
  \return \safe \;
}
\While{$true$} 
{
  \uIf{$v$ is $\gamma$-complete} {
    \return \unsafe;
  }
  $d \leftarrow decide(v)$ \;
  $v \leftarrow v \meet d$ \; 
  $\mathcal{T} \leftarrow \mathcal{T} . d$ \; 
  $\mathcal{R}[|\mathcal{T}|] \leftarrow nil$ \;
  $result \leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$\;
  \Do{$result == \conflict$} {
    learn() \;
    \uIf{$\neg$ conflict\_analysis()} {
      return \safe \;  
    }
    result $\leftarrow \deduce(S,v,\mathcal{T},\mathcal{R})$ \;
  }
}
\end{small}
\caption{Abstract Conflict Driven Clause Learning $\langle ACDCL(S) \rangle$ \label{Alg:acdcl}}
\end{algorithm2e}
%
\Omit {
Static program analysis based on abstract
interpretation~\cite{DBLP:conf/emsoft/Cousot07} has been widely used to
verify certain classes of properties for safety-critical systems.  In
abstract interpretation, a given program is analysed with respect to a set
of given abstract domains.  However, ACDCL is a novel program analysis 
technique that embeds an abstract domain inside the CDCL algorithm.
From the abstract interpretation point of view, ACDCL is an abstract 
interpreter that uses decision and learning to increase transformer precision. 
From the decision procedure perspective, ACDCL is a SAT solver for program 
analysis constraints and is thus a strict generalisation of propositional CDCL solvers.
Constraint propagation in ACDCL uses fixed point iteration, decisions restrict the 
range of intervals and learning generates program analysis constraints (not assumptions) 
that preserve the error reachability.  Moreover, ACDCL implicitly 
perform program and property driven trace partitioning to increase the precision
of the analysis.  
}
Algorithm~\ref{Alg:acdcl} presents an overview of the ACDCL algorithm.
The algorithm begins with a set $S$ of abstract deduction transformer 
$\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$, an abstract valuation $\langle v \leftarrow \top \rangle$, 
and an empty propagation trail and reason trail, $\mathcal{T}$, $\mathcal{R}$, 
respectively.  The propagation trail stores all meet irreducibles inferred 
by the abstact model search phase (deductions and decisions), while the 
reason trail maps elements of propagation trail to transformers that were 
used to drive them.  

The procedure $deduce(S,v,\mathcal{T},\mathcal{R})$ computes a greatest 
fixed point over the transformers in F that refines the abstract valuation 
$v$, similar to BCP step in SAT solvers.  If the result of $deduce$ 
returns {\em CONFLICT} ($\perp$), the algorithm terminates with {\em safe}. 
Else, the analysis enters into the while($true$) loop and makes a new decision 
by a call to $decide(v)$ which returns a new meet irreducible $d$ that is
consistent to the state of the solver.  If $d$ refines the current abstract 
value $v$, the corresponding propagation and reason trail, $\mathcal{T}$ 
and $\mathcal{R}$ are updated. 

For example, a decision in interval domain restrict the range of 
intervals for variables, so the analysis jumps under a 
greatest fixed-point. Note that the widening operation in abstract interpretation 
jumps above a least fixed-point, so decisions can be viewed as 
{\em dual widening}.  The procedure $deduce$ is called next to infer new 
set of meet irreducibles for the current decision.  The model search phase 
alternates between the decision and deduction until the result of deduction 
is either $\gamma$-complete~\cite{gamma} or the deduction leads to a {\em CONFLICT}.  
If $v$ is $\gamma$-complete, then it cannot be refined further.  Thus, the 
algorithm returns the error trace $v$ and terminates with UNSAFE or the 
current abstraction is insufficient to determine the satisfiability of $\varphi$.  
However, in case of {\em CONFLICT}, the algorithm enters in to 
$conflict\_analysis()$ phase to learn the reason for {\em conflict}.  
There can be multiple incomparable reasons for conflict -- based on 
the choice of Unique Implication Point (UIP)~\cite{cdcl}.  ACDCL heuristically 
choose one reason.  A learnt clause must include asserting cuts which 
guarantees derivation of new meet irreducibles after backtracking. The clause 
learning and backtracking continues as long as the result of deduction 
is conflicting ($\perp$), that is, the abstract valuation $v$ does not
abstractly satisfy the formula.  If no further backtrack is possible, 
then the algorithm terminates and $\varphi$ is {\em SAFE}. Else, the 
algorithm makes a new decision and the above process is repeated 
until a real counterexample is obtained or the algorithm backtracks to 
decision level 0 after a conflict in which case it returns {\em SAFE}. 


