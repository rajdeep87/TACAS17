\section{Deduction}
In a typical abstract interpretation based galois-connection settings over 
an over-approximate domain, every concrete elements have a unique over-approximate 
representation in the abstract.  Likewise, every concrete transformer is
over-approximated by a unique abstract transformer.  We now define a abstract 
deduction transformer.  

\begin{definition}{(Abstract Deduction Transformer)} An abstract deduction
transformer, $\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$ is a sound approximation of a concrete model transformer
$ded_{\varphi}$, given by $\widehat{ded_{\varphi}} : A \rightarrow A$, such that 
$\forall a \in A: \widehat{ded_{\varphi}}(a) \in \{\top, \bot, m\}$, where 
$m \in A$ is a meet irreducible.   
\end{definition}

Let us consider a formula $\varphi = (x:=y-1)$ to be analyzed over 
an interval abstract domain, $A = ItvDom$, and let $a = \langle y:[3, 5]
\rangle \in ItvDom$, then $\widehat{ded_{\varphi}}(a) = a \meet \langle x:[2, 4]
\rangle$.  An abstract deduction transformer is typically computed in the form 
of strongest post-condition or a weakest pre-condition of a formula in the 
abstract domain.  

A meet decomposition of the outcome of abstract deduction transformer 
is obtained by taking a meet of the element $\langle y:[3, 5] \rangle, 
\langle x:[2, 4] \rangle \in ItvDom$ which gives set of meet irreducibles, 
$\{ \langle y \succeq 3 \rangle, \langle y \preceq 5 \rangle, 
\langle x \succeq 2 \rangle, \langle x \preceq 4 \rangle \}$, that are 
precisely complementable.

\begin{definition}{(Meet Decomposition)} A meet decomposition of an abstract
element $a \in A$ is a set of meet irreducibles $M \subseteq A$ such that 
$\forall m_i \in M, \meet(m_i) = a$, where $max(i) = |M|$.
\end{definition}
 
For a program with $N$ variables, let $L$ be the total number of 
meet irreducibles returned by a domain $D$.  For $D$ = {\em ItvDom}, the 
maximum value of $L$ is $2*N$, whereas the maximum value of $L$ is 
$2*(N^2)$ for $D$ = {\em OctDom}. Note that an octagon is the conjunction 
of all octagonal inequalities in the set $L$.
%
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((guard0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (guard1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !guard1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{swssa}
\end{figure}
%
\subsection{Iteration Strategy For Abstract Deduction Transformer}
Algorithm~\label{Alg:iteration} presents the modelSearch procedure. 
our deduction high-level sketch for the abstract deduction transformer.
%The inputs are Input{Set of $\widehat{ded_{\varphi}}$ for $\varphi$ from Program $\mathcal{P}$, trail $\mathcal{T}$ and assertion $A$}
$statement \in S$, $statement$ is a meet irreducible deduction transformer.
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{deduce}{deduce}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwData{safe}{safe}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of $\widehat{ded_{\varphi}}$ for $\varphi$ over Abstract domain $A$,
abstract value $v$, propagation trail $\mathcal{T}$, reason trail $\mathcal{R}$}
\Output{The status (\safe or \unsafe or \unknown)}
worklist $\leftarrow$ initialize\_worklist($S$) \;
\Loop{}
{
// Greatest fixed point \;
\While{$!worklist.empty()$} 
{
  $\langle live\_vars, s \rangle \leftarrow$ worklist.pop() \;
  $\mathit{meet\_irrd} \leftarrow$ domain(s, live\_vars, $v$)\;
  // check if the domain deduce BOTTOM \;
  \uIf{$meet\_irrd == \bot$} {
    $\mathcal{R}[\bot] \leftarrow s$ \;
    // empty the worklist \;
    worklist.delete() \;
    \return \safe \;
  }
  \uElse
  {
    // add deduction to trail \;
    $\mathcal{T} \leftarrow \mathcal{T} . \mathit{meet\_irrd}$ \; 
    $v \leftarrow v \meet \mathit{meet\_irrd}$ \; 
    $\mathcal{R}[|\mathcal{T}|] \leftarrow s$ \;
    // update the worklist \;
    worklist.update(v, s) \; 
  }
}
// check for counterexample\;
\uIf{$v$ is gamma\_complete} {
  \return \unsafe;
}
$d \leftarrow decide(v)$ \;
\uIf{$v \sqsubseteq d$} {
\return \unknown \;
}
// add decision to trail\;
$\mathcal{T} \leftarrow \mathcal{T} . d$ \; 
$v \leftarrow v \meet d$ \; 
$\mathcal{R}[|\mathcal{T}|] \leftarrow nil$ \;
}
\end{small}
\caption{Abstract Model Search Procedure\label{Alg:model_search}}
\end{algorithm2e}


\subsection{Forward Iteration Strategy}
For forward iteration on Figure~\ref{swssa}, we need atleast 
one decision to deduce BOTTOM and prove safety. The deduction 
happens from right to left in forward iteration strategy.

The initialization of live variable and subsequent update depends on the iteration strategy.

\subsection{Backward Iteration Strategy}

\subsection{Chaotic Iteration Strategy}  
The set of octagonal equilities corresponding to Figurei~\ref{sw-ssa}
is shown below. For chaotic, no decision is required to deduce BOTTOM.

\Omit {
Let us consider an example. 
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagons \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int id(int a) {
  return a;
}
int main() {
 int x,y,z;
 _Bool c;
 if (c)
   x = -1;
 else
   x = 2;
 int k = id(x);
 z = x * k;
 assert((z!=-2));
}
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true,language=C]
cond == (x == y)
guard1 == (cond19 && guard0)
x' == 1u + x
x' == 1u + y || !guard1
guard0 == TRUE
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true,language=C]

\end{lstlisting}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal inequalities}
\label{swssa}
\end{figure}
}

With forward iteration strategy using octagon domian, the program 
is proved without any decision. However, with the forward strategy
using interval domain, we just required one decision to prove the program. 
