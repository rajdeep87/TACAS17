\section{Abstract Model Search}
%
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((g0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (g1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{ssa}
\end{figure}
%
%    
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{deduce}{deduce}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwData{sat}{SAT}
\SetKwData{conflict}{CONFLICT}
\SetKwData{unsat}{UNSAT}
\SetKwData{unknown}{UNKNOWN}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of $\widehat{ded_{\varphi}}$ for $\varphi$ over Abstract domain $A$,
abstract valuation $v$, propagation trail $\mathcal{T}$, reason trail $\mathcal{R}$}
\Output{The status (\sat or \conflict or \unknown)}
worklist $\leftarrow$ initialize\_worklist($S$) \;
\Loop{}
{
// Greatest fixed point \;
\While{$!worklist.empty()$} 
{
  $\langle live\_vars, s \rangle \leftarrow$ worklist.pop() \;
  $\mathit{meet\_irrd} \leftarrow$ domain(s, live\_vars, $v$)\;
  \uIf{$meet\_irrd == \bot$} {
    $\mathcal{R}[\bot] \leftarrow s$ \;
    worklist.delete() \;
    \return \conflict \;
  }
  \uElse
  {
    $\mathcal{T} \leftarrow \mathcal{T} . \mathit{meet\_irrd}$ \; 
    $v \leftarrow v \meet \mathit{meet\_irrd}$ \; 
    $\mathcal{R}[|\mathcal{T}|] \leftarrow s$ \;
    worklist.update(v, s) \; 
  }
}
\uIf{$v$ is $\gamma$-complete} {
  \return \sat;
}
\uElse {
 \return \unknown \;
}
}
\end{small}
\caption{Abstract Model Search $\langle deduce(S,v,\mathcal{T},\mathcal{R}) \rangle$ \label{Alg:ms}}
\end{algorithm2e}
%  
A model search procedure in a SAT solver involves two steps -- {\em deductions} 
using unit rule refines current partial assignments and 
{\em decisions} to heuristically guess a value for an unassigned 
literal.  A unit rule overapproximates a model transformer and deduction 
computes a greatest fixed point over the partial assignments
domain~\cite{dhk2013-popl}.  We present an abstract model search procedure 
that computes a greatest fixed point over meet irreducible deduction 
transformer in $S$.  
%

%-------------------------------------------------------------------------------
\subsection{Abstract Transformers} \label{sec:abst}
%-------------------------------------------------------------------------------

To make our algorithm efficient, we have to focus abstract
transformers on performing only the minimally necessary
work. 
%
We thus define a specialised variant of the transformer to compute
deductions w.r.t.\ a given subdomain $L\sqsubseteq A$; $\bot,\top \in L$.
\[\llbracket s \rrbracket^\sharp(a,L)=\min \{a'\mid a'\in L, a'\models s\}\]
We have the property $\llbracket s \rrbracket^\sharp(a)\sqsubseteq \llbracket s \rrbracket^\sharp(a,L)$.
%
For example, for
$a=(0\leq y \leq 1 \wedge 5\leq z)$ we have
$\llbracket x=y+z\rrbracket^\sharp(a,\{x\})=(x\geq 6)$, whereas
$\llbracket x=y+z\rrbracket^\sharp(a,\{y,z\})=\top$.
%
If $L=A$ then intuitively $a$ is intersected with the constraint $s$.
Yet, with the help of $L$ we can also control whether to perform
forward (right-hand side to left-hand side, $L=\{x\}$ in the above
example) or backward (lhs to rhs, $L=\{y,z\}$) propagation.

Moreover, we want to know what the reasons for a specific deduction are.
\[ded(s,a,L)=\{R\rightarrow d\mid R=reasons(s,a,L,d), d \in decomp(\llbracket s \rrbracket^\sharp(a,L))\}\]
where 
$reasons(s,a,L,d)=\min \{R'\mid R'\subseteq decomp(a), \llbracket s\rrbracket^\sharp(R,L)=d\}$.

\pscmt{give an example for $ded$, link it to the reason trail}

\pscmt{define $ded$ for all statements, connect this to worklist}

\pscmt{link livevars to $L$ -- the subdomain spanned by livevars}

%-------------------------------------------------------------------------------
\subsection{Algorithm for Deduction Phase}
%-------------------------------------------------------------------------------
%
\rmcmt{Talk about lazy closure operation}
Algorithm~\ref{Alg:ms} presents the deduction phase in abstract model search procedure.
A {\em worklist} is initialized following a heuristics choice for iteration 
strategies. A {\em forward} iteration strategy initializes the worklist with 
transformers that has constants in the right-hand side. Whereas, a {\em backward} 
iteration strategy starts with a set of assertions. On the other hand, a 
{\em chaotic} iteration strategy initializes the worklist with set of all 
transformers.  For every meet irreducible deduction transformer $s \in S$ 
passed to the abstract domain, if the domain infers a new meet irreducible 
$\mathit{meet\_irrd}$, it is added to $\mathcal{T}$.  Additionally, the reason 
trail $\mathcal{R}$ is updated with the transformer $s$ as the reason for inferring
$\mathit{meet\_irrd}$. If a conflict is deduced, that is, $\mathit{meet\_irrd} = \bot$ 
is inferred by the domain, the algorithm terminates with CONFLICT.  However,
when a fixed-point is reached, the abstract valuation $v$ is checked for set of
models.  This is determined by checking whether the set of assignments in $v$ is 
$\gamma$-complete~\cite{gamma}.  This can be achieved by checking if there is a 
concrete solution $c$ such that the inequality $c(x) \subseteq \gamma \circ
v(x)$ holds for every meet irreducible $x$.  If $v$ is $\gamma$-complete, that is, the 
abstract valuation $v$ is abstractly satisfying, the abstract model 
search terminates with SAT.  Otherwise, the algorithm returns UNKNOWN and the 
model search procedure makes a new decision.    



