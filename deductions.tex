\section{Abstract Model Search}
%
\Omit {
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((g0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (g1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{ssa}
\end{figure}
}
%
%    
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{deduce}{deduce}
\SetKwFunction{print}{print}
\SetKw{return}{return}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwData{sat}{sat}
\SetKwData{conflict}{conflict}
\SetKwData{unsat}{unsat}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{%Abstract domain $A$
Program $\mathcal{S}$,
propagation trail $\mathcal{T}$, reason trail $\mathcal{R}$,
propagation heuristics $H$}
\Output{\sat or \conflict or \unknown}
$\mathit{worklist} \leftarrow H.\mathit{initialize\_worklist}(\mathcal{S})$ \;
\While{$!\mathit{worklist.empty}()$} 
{
  $(s,\mathit{live\_vars}) \leftarrow \mathit{worklist.pop}()$ \;
  $v \leftarrow ded(s, \mathit{espan}(\mathit{live\_vars}), \mathit{abs}(\mathcal{T}))$\;
  \uIf{$v = \bot$} {
    $\mathcal{R}[\bot] \leftarrow s$ \;
%\pscmt{how is this used in the conflict
%    analysis? wouldn't it be more uniform to add $\bot$ to the $\mathcal{T}$?}
%    \rmcmt{UIP uses the transformer stored at $\mathcal{R}[\bot]$ to derive the
%    cut. No, we dont want to make the trail inconsistent by adding $\bot$}
    $\mathit{worklist.clear}()$ \;
%\pscmt{why can't you clean up the worklist during conflict analysis? it seems inefficient to throw everything away...}
%    \rmcmt{When a bottom is deduced, the direction of search
%    changes--so the worklist is populated with new set of statement and must be
%    flushed out} 
    \return \conflict \;
  }
  \uElse
  {
    $\mathcal{T} \leftarrow \mathcal{T} \cdot \mathit{decomp}(v)$ \; 
%    $v \leftarrow v \meet \mathit{meet\_irrd}$ \; 
    $\mathcal{R}[|\mathcal{T}|] \leftarrow s$ \;
    $H.\mathit{update\_worklist}(v, \mathit{worklist})$ \; 
  }
}
\lIf{$\mathit{abs}(\mathcal{T})$ is $\gamma$-complete} {
  \return \sat;
}
 \return \unknown \;

\end{small}
\caption{Abstract Model Search $\mathit{deduce}(\mathcal{S},\mathcal{T},\mathcal{R},H)$ \label{Alg:ms}}
\end{algorithm2e}
%  
A model search procedure in a SAT solver involves two steps -- {\em deductions} 
using the unit rule refines current partial assignments and 
{\em decisions} to heuristically guess a value for an unassigned 
literal.  The unit rule overapproximates a model transformer and deduction 
computes a greatest fixed point over the partial assignments
domain~\cite{dhk2013-popl}.  We present an abstract model search procedure 
that computes a greatest fixed point over meet irreducible deduction 
transformer in $S$ \pscmt{???}.  
%

%-------------------------------------------------------------------------------
\subsection{Abstract Transformers} \label{sec:abst}
%-------------------------------------------------------------------------------

To make our algorithm efficient, we have to focus abstract
transformers on performing only the minimally necessary
work. 
%
We thus define a specialised variant of the transformer to compute
deductions w.r.t.\ a given subdomain $L\subseteq A$; $\bot,\top \in L$.
\[\llbracket s \rrbracket^\sharp(a,L)=\bigsqcup \{a'\mid a'\in L, a' \sqsubseteq a, a'\models s\}\]
We have the property $\llbracket s \rrbracket^\sharp(a)\sqsubseteq \llbracket s \rrbracket^\sharp(a,L)$.
%
For example, for
$a=(0\leq y \leq 1 \wedge 5\leq z)$ we have
$\llbracket x=y+z\rrbracket^\sharp(a,\{x\})=(x\geq 6)$, whereas
$\llbracket x=y+z\rrbracket^\sharp(a,\{y,z\})=\top$.
%
If $L=A$ then intuitively $a$ is intersected with the constraint $s$.
Yet, with the help of $L$ we can also control whether to perform
forward (right-hand side to left-hand side, $L=\{x\}$ in the above
example) or backward (lhs to rhs, $L=\{y,z\}$) propagation.

%Moreover, we want to know what the reasons for a specific deduction are.
%\[ded(s,a,L)=\{R\rightarrow d\mid R=reasons(s,a,L,d), d \in decomp(\llbracket s \rrbracket^\sharp(a,L))\}\]
%where 
%$reasons(s,a,L,d)=\text{argmin}_{R\in\{R'\mid R'\subseteq decomp(a), \llbracket s\rrbracket^\sharp(R,L)=d\}} |R| $.

\pscmt{give an example for $ded$, link it to the reason trail}

\pscmt{define $ded$ for all statements, connect this to worklist}

\pscmt{link livevars to $L$ -- the subdomain spanned by livevars}

%-------------------------------------------------------------------------------
\subsection{Algorithm for Deduction Phase}
%-------------------------------------------------------------------------------
%
\rmcmt{Talk about lazy closure operation}

\pscmt{
Rough and sketchy:
%
$espan(V)=$all meet irreducibles $\in A$ that contain at most one variable that is not in $V$.
%
$select(S,PV)$ is the set of statements that contain variables in $PV$ where $PV$ is the set of variables in the previous deduction.
%
$LV(s)$ are the live variables of a statement $s$, i.e.\ the intersection of $PV$ with the variables in $s$.
\begin{theorem}
$$
\gfp\lambda a. \bigsqcap_{s\in S} ded(s,a,A) = 
\gfp\lambda a. \bigsqcap_{s\in select(S,PV)} ded(s,a,espan(LV(s)))
$$
\end{theorem}
Proof sketch: see Appendix
}

Algorithm~\ref{Alg:ms} presents the deduction phase in abstract model
search procedure. \pscmt{The propagation heuristics $H$ provides two
  functions $\mathit{initialize\_worklist}$ and
  $\mathit{update\_worklist}$. Describe them for the different
  heuristics (already done for initialize, TBD for update...}
A {\em worklist} is a queue which contains \rmcmt{abstract deduction
transformers}.  A {\em worklist} is initialized following a heuristics 
choice for iteration strategies. A {\em forward} iteration 
strategy initializes the worklist with \rmcmt{abstract} transformers that 
has constants in the right-hand side. Whereas, a {\em backward} 
iteration strategy starts with a set of assertions. On the other hand, a 
{\em multi-way} iteration strategy initializes the worklist with set of all 
transformers and performs both forward and backward propagations in tandem.  
For every meet irreducible deduction transformer \pscmt{rename} $s \in S$ 
passed to the abstract domain, if the domain infers a new meet irreducible 
$\mathit{meet\_irrd}$, it is added to $\mathcal{T}$ \pscmt{It usually infers several ones.}.  Additionally, the reason 
trail $\mathcal{R}$ \pscmt{define} is updated with the transformer $s$ as the reason for inferring
$\mathit{meet\_irrd}$. If a conflict is deduced, that is, $\mathit{meet\_irrd} = \bot$ 
is inferred by the domain, the algorithm terminates with \textsf{conflict}.  However,
when a fixed-point is reached, the abstract valuation $v$ is checked for set of
models.  This is determined by checking whether the set of assignments in $v$ is 
$\gamma$-complete~\cite{dhk2013-popl}. If $v$ is $\gamma$-complete, that is, the 
abstract valuation $v$ is abstractly satisfying, the abstract model 
search terminates with \textsf{sat}.  Otherwise, the algorithm returns \textsf{unknown} and the 
model search procedure makes a new decision.    



