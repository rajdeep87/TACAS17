\section{Deduction}
In a typical abstract interpretation based galois-connection settings over 
an over-approximate domain, every concrete elements have a unique over-approximate 
representation in the abstract.  Likewise, every concrete transformer is
over-approximated by a unique abstract transformer.  We now define a abstract 
deduction transformer.  

\begin{definition}{(Abstract Deduction Transformer)} An abstract deduction
transformer, $\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$ is a sound approximation of a concrete model transformer
$ded_{\varphi}$, given by $\widehat{ded_{\varphi}} : A \rightarrow A$, such that 
$\forall a \in A: \widehat{ded_{\varphi}}(a) \in \{\top, \bot, m\}$, where 
$m \in A$ is a meet irreducible.   
\end{definition}

Let us consider a formula $\varphi = (x:=y-1)$ to be analyzed over 
an interval abstract domain, $A = ItvDom$, and let $a = \langle y:[3, 5]
\rangle \in ItvDom$, then $\widehat{ded_{\varphi}}(a) = a \meet \langle x:[2, 4]
\rangle$.  An abstract deduction transformer is typically computed in the form 
of strongest post-condition or a weakest pre-condition of a formula in the 
abstract domain.  

A meet decomposition of the outcome of abstract deduction transformer 
is obtained by taking a meet of the element $\langle y:[3, 5] \rangle, 
\langle x:[2, 4] \rangle \in ItvDom$ which gives set of meet irreducibles, 
$\{ \langle y \succeq 3 \rangle, \langle y \preceq 5 \rangle, 
\langle x \succeq 2 \rangle, \langle x \preceq 4 \rangle \}$, that are 
precisely complementable.

\begin{definition}{(Meet Decomposition)} A meet decomposition of an abstract
element $a \in A$ is a set of meet irreducibles $M \subseteq A$ such that 
$\forall m_i \in M, \meet(m_i) = a$, where $max(i) = |M|$.
\end{definition}
 
For a program with $N$ variables, let $L$ be the total number of 
meet irreducibles returned by a domain $D$.  For $D$ = {\em ItvDom}, the 
maximum value of $L$ is $2*N$, whereas the maximum value of $L$ is 
$2*(N^2)$ for $D$ = {\em OctDom}. Note that an octagon is the conjunction 
of all octagonal inequalities in the set $L$.
%
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((guard0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (guard1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !guard1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{swssa}
\end{figure}
%
%    
\begin{algorithm2e}[htbp]
\DontPrintSemicolon
\SetKwFunction{deduce}{deduce}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwData{sat}{SAT}
\SetKwData{unsat}{UNSAT}
\SetKwData{unknown}{UNKNOWN}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of $\widehat{ded_{\varphi}}$ for $\varphi$ over Abstract domain $A$,
abstract value $v$, propagation trail $\mathcal{T}$, reason trail $\mathcal{R}$}
\Output{The status (\sat or \unsat or \unknown)}
worklist $\leftarrow$ initialize\_worklist($S$) \;
\Loop{}
{
// Greatest fixed point \;
\While{$!worklist.empty()$} 
{
  $\langle live\_vars, s \rangle \leftarrow$ worklist.pop() \;
  $\mathit{meet\_irrd} \leftarrow$ domain(s, live\_vars, $v$)\;
  // check if the domain deduce BOTTOM \;
  \uIf{$meet\_irrd == \bot$} {
    $\mathcal{R}[\bot] \leftarrow s$ \;
    // empty the worklist \;
    worklist.delete() \;
    \return \sat \;
  }
  \uElse
  {
    // add deduction to trail \;
    $\mathcal{T} \leftarrow \mathcal{T} . \mathit{meet\_irrd}$ \; 
    $v \leftarrow v \meet \mathit{meet\_irrd}$ \; 
    $\mathcal{R}[|\mathcal{T}|] \leftarrow s$ \;
    // update the worklist \;
    worklist.update(v, s) \; 
  }
}
// check for counterexample\;
\uIf{$v$ is $\gamma$-complete} {
  \return \unsat;
}
$d \leftarrow decide(v)$ \;
\uIf{$v \sqsubseteq d$} {
\return \unknown \;
}
// add decision to trail\;
$\mathcal{T} \leftarrow \mathcal{T} . d$ \; 
$v \leftarrow v \meet d$ \; 
$\mathcal{R}[|\mathcal{T}|] \leftarrow nil$ \;
}
\end{small}
\caption{Abstract Model Search\label{Alg:ms}}
\end{algorithm2e}
%
\subsection{Abstract Model Search}
Algorithm~\ref{Alg:ms} presents the abstract model search procedure. 
In propositional case, a model search involves two steps -- 
{\em deductions} using unit rule refines current partial assignments 
and {\em decisions} to heuristically guess a value for an unassigned 
literal.  A unit rule overapproximates a model transformer and deduction 
computes a greatest fixed point over the partial assignments
domain~\cite{dhk2013-popl}.  Similarly, an abstract model search computes
a greatest fixed point over meet irreducible deduction transformer in $S$.  


A {\em worklist} is initialized following a heuristics choice for iteration 
strategies. A {\em forward} iteration strategy initializes the worklist with 
transformers that has constants in the right-hand side. Whereas, a {\em backward} 
iteration strategy starts with a set of assertions. On the other hand, a 
{\em chaotic} iteration strategy initializes the worklist with set of all 
transformers.  For every meet irreducible deduction transformer $s \in S$ 
passed to the abstract domain, if the domain infers a new meet irreducible 
$\mathit{meet\_irrd}$, it is added to $\mathcal{T}$.  Additionally, the reason 
trail $\mathcal{R}$ is updated with the transformer $s$ as the reason for inferring
$\mathit{meet\_irrd}$. If a conflict is deduced, that is, $\mathit{meet\_irrd} = \bot$ 
is inferred by the domain, the algorithm terminates with UNSAT.  However,
when a fixed-point is reached, the abstract value $v$ is checked for set of
models.  This is done by checking whether the set of assignments in $v$ is 
$\gamma$-complete~\cite{gamma}.  If $v$ is $\gamma$-complete, the abstract model 
search terminates with SAT.  Otherwise, a decision is made by calling a 
procedure $decide(v)$ which returns a meet irreducible $d$.  If $d$ refines the 
current abstract value $v$, then the corresponding propagation and reason trail,
$\mathcal{T}$ and $\mathcal{R}$, are updated. Else, the model search procedure 
terminates with UNKNOWN.      


