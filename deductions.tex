\section{Abstract Model Search}
%
\Omit {
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((g0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (g1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{ssa}
\end{figure}
}
%
%    
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{deduce}{deduce}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwData{sat}{SAT}
\SetKwData{conflict}{CONFLICT}
\SetKwData{unsat}{UNSAT}
\SetKwData{unknown}{UNKNOWN}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{Set $S$ of $\widehat{ded_{\varphi}}$ for $\varphi$ over Abstract domain $A$,
abstract valuation $v$, propagation trail $\mathcal{T}$, reason trail $\mathcal{R}$}
\Output{The status (\sat or \conflict or \unknown)}
worklist $\leftarrow$ initialize\_worklist($S$) \;
\Loop{}
{
// Greatest fixed point \;
\While{$!worklist.empty()$} 
{
  $\langle live\_vars, s \rangle \leftarrow$ worklist.pop() \;
  $\mathit{meet\_irrd} \leftarrow$ domain(s, live\_vars, $v$)\;
  \uIf{$meet\_irrd == \bot$} {
    $\mathcal{R}[\bot] \leftarrow s$ \;
    worklist.delete() \;
    \return \conflict \;
  }
  \uElse
  {
    $\mathcal{T} \leftarrow \mathcal{T} . \mathit{meet\_irrd}$ \; 
    $v \leftarrow v \meet \mathit{meet\_irrd}$ \; 
    $\mathcal{R}[|\mathcal{T}|] \leftarrow s$ \;
    worklist.update(v, s) \; 
  }
}
\uIf{$v$ is $\gamma$-complete} {
  \return \sat;
}
\uElse {
 \return \unknown \;
}
}
\end{small}
\caption{Abstract Model Search $\langle deduce(S,v,\mathcal{T},\mathcal{R}) \rangle$ \label{Alg:ms}}
\end{algorithm2e}
%  
A model search procedure in a SAT solver involves two steps -- {\em deductions} 
using the unit rule refines current partial assignments and 
{\em decisions} to heuristically guess a value for an unassigned 
literal.  The unit rule overapproximates a model transformer and deduction 
computes a greatest fixed point over the partial assignments
domain~\cite{dhk2013-popl}.  We present an abstract model search procedure 
that computes a greatest fixed point over meet irreducible deduction 
transformer in $S$ \pscmt{???}.  
%

%-------------------------------------------------------------------------------
\subsection{Abstract Transformers} \label{sec:abst}
%-------------------------------------------------------------------------------

To make our algorithm efficient, we have to focus abstract
transformers on performing only the minimally necessary
work. 
%
We thus define a specialised variant of the transformer to compute
deductions w.r.t.\ a given subdomain $L\subseteq A$; $\bot,\top \in L$.
\[\llbracket s \rrbracket^\sharp(a,L)=\bigsqcup \{a'\mid a'\in L, a' \sqsubseteq a, a'\models s\}\]
We have the property $\llbracket s \rrbracket^\sharp(a)\sqsubseteq \llbracket s \rrbracket^\sharp(a,L)$.
%
For example, for
$a=(0\leq y \leq 1 \wedge 5\leq z)$ we have
$\llbracket x=y+z\rrbracket^\sharp(a,\{x\})=(x\geq 6)$, whereas
$\llbracket x=y+z\rrbracket^\sharp(a,\{y,z\})=\top$.
%
If $L=A$ then intuitively $a$ is intersected with the constraint $s$.
Yet, with the help of $L$ we can also control whether to perform
forward (right-hand side to left-hand side, $L=\{x\}$ in the above
example) or backward (lhs to rhs, $L=\{y,z\}$) propagation.

%Moreover, we want to know what the reasons for a specific deduction are.
%\[ded(s,a,L)=\{R\rightarrow d\mid R=reasons(s,a,L,d), d \in decomp(\llbracket s \rrbracket^\sharp(a,L))\}\]
%where 
%$reasons(s,a,L,d)=\text{argmin}_{R\in\{R'\mid R'\subseteq decomp(a), \llbracket s\rrbracket^\sharp(R,L)=d\}} |R| $.

\pscmt{give an example for $ded$, link it to the reason trail}

\pscmt{define $ded$ for all statements, connect this to worklist}

\pscmt{link livevars to $L$ -- the subdomain spanned by livevars}

%-------------------------------------------------------------------------------
\subsection{Algorithm for Deduction Phase}
%-------------------------------------------------------------------------------
%
\rmcmt{Talk about lazy closure operation}

\pscmt{
Rough and sketchy:
%
$espan(V)=$all meet irreducibles $\in A$ that contain at most one variable that is not in $V$.
%
$select(S,PV)$ is the set of statements that contain variables in $PV$ where $PV$ is the set of variables in the previous deduction.
%
$LV(s)$ are the live variables of a statement $s$, i.e.\ the intersection of $PV$ with the variables in $s$.
\begin{theorem}
$$
\gfp\lambda a. \bigsqcap_{s\in S} ded(s,a,A) = 
\gfp\lambda a. \bigsqcap_{s\in select(S,PV)} ded(s,a,espan(LV(s)))
$$
\end{theorem}
Proof sketch:
When computing $ded$, we obtain a deduction that affects variables $V$.
This has two consequences: (1) we have to compute the closure; (2) we have to propagate through all statements $s$ affected by the changes to $V$. 
We do only (2): $espan$ augments the set of affected variables by one transitivity step that we would have to compute in the closure. $ded$ on this subdomain hence performs the deduction w.r.t. $a$ and $s$ plus one transitivity step of the closure. Thus, by induction, we eventually compute the entire closure just by doing (2).

What are the consequences regarding complexity?
Assuming we require $m$ iterations to reach the fixed point with eager closure; we have to perform $|A|^c|S|m$ (idealised) computation steps to do that (where $c=3$ for octagons). With the lazy closure we have to do $|L|^c|S|mk$ computations taking into account that we need $k$ times more iterations to converge. Hence, the approach pays off if $k<<\frac{|A|^c}{|L|^c}$, which seems likely for $c=3$.

}

Algorithm~\ref{Alg:ms} presents the deduction phase in abstract model search procedure.
A {\em worklist} is initialized following a heuristics choice for iteration 
strategies. A {\em forward} iteration strategy initializes the worklist with 
transformers that has constants in the right-hand side. Whereas, a {\em backward} 
iteration strategy starts with a set of assertions. On the other hand, a 
{\em multi-way} iteration strategy initializes the worklist with set of all 
transformers.  For every meet irreducible deduction transformer \pscmt{rename} $s \in S$ 
passed to the abstract domain, if the domain infers a new meet irreducible 
$\mathit{meet\_irrd}$, it is added to $\mathcal{T}$ \pscmt{It usually infers several ones.}.  Additionally, the reason 
trail $\mathcal{R}$ \pscmt{define} is updated with the transformer $s$ as the reason for inferring
$\mathit{meet\_irrd}$. If a conflict is deduced, that is, $\mathit{meet\_irrd} = \bot$ 
is inferred by the domain, the algorithm terminates with CONFLICT.  However,
when a fixed-point is reached, the abstract valuation $v$ is checked for set of
models.  This is determined by checking whether the set of assignments in $v$ is 
$\gamma$-complete~\cite{dhk2013-popl}. If $v$ is $\gamma$-complete, that is, the 
abstract valuation $v$ is abstractly satisfying, the abstract model 
search terminates with SAT.  Otherwise, the algorithm returns UNKNOWN and the 
model search procedure makes a new decision.    



