\section{Abstract Model Search}
%
\Omit {
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((g0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (g1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{ssa}
\end{figure}
}
%
%    
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKw{return}{return}
\SetKwData{sat}{sat}
\SetKwData{conflict}{conflict}
\SetKwData{unsat}{unsat}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFor{Loop}{Loop}{}{}
\SetKw{KwNot}{not}
\begin{small}
\Input{A program in the form of a set of abstract transformers $\abstransset$,
a propagation trail $\trail$, and a reason trail $\reasons$.}
\Output{\sat or \conflict or \unknown}
$\worklist \leftarrow \initworklist_{\propheur}(\abstransset)$ \;
\While{$!\mathit{worklist.empty}()$} 
{
%  $(\abstransel,\livevars) \leftarrow \mathit{worklist.pop}()$ \;
  $\abstransel{\subdomain} \leftarrow \mathit{worklist.pop}()$ \;
%  $v \leftarrow ded(s, \makesubdomain(\livevars), \abs(\trail))$\;
  $v \leftarrow \abstransel{\subdomain}(\abs(\trail))$\;
  \uIf{$v = \bot$} {
    $\reasons[\bot] \leftarrow \abstransel{\subdomain}$ \;
%\pscmt{how is this used in the conflict
%    analysis? wouldn't it be more uniform to add $\bot$ to the $\trail$?}
%    \rmcmt{UIP uses the transformer stored at $\reasons[\bot]$ to derive the
%    cut. No, we dont want to make the trail inconsistent by adding $\bot$}
    $\mathit{worklist.clear}()$ \;
%\pscmt{why can't you clean up the worklist during conflict analysis? it seems inefficient to throw everything away...}
%    \rmcmt{When a bottom is deduced, the direction of search
%    changes--so the worklist is populated with new set of statement and must be
%    flushed out} 
    \return \conflict \;
  }
  \uElse
  {
    $\trail \leftarrow \trail \cdot \decomp(v)$ \; 
%    $v \leftarrow v \meet \mathit{meet\_irrd}$ \; 
    $\reasons[|\trail|] \leftarrow s$ \;
    $\updateworklist_{\propheur}(v, \worklist)$ \; 
  }
}
\lIf{$\abs(\trail)$ is $\gamma$-complete} {
  \return \sat;
}
 \return \unknown \;

\end{small}
\caption{Abstract Model Search $\mathit{deduce}_{\propheur}(\abstransset,\trail,\reasons)$ \label{Alg:ms}}
\end{algorithm2e}
%  
A model search procedure in a SAT solver involves two steps -- {\em deductions} 
using the unit rule refines current partial assignments and 
{\em decisions} to heuristically guess a value for an unassigned 
literal.  The unit rule overapproximates a model transformer and deduction 
computes a greatest fixed point over the partial assignments
domain~\cite{dhk2013-popl}.  We present an abstract model search procedure 
that computes a greatest fixed point over meet irreducible deduction 
transformer in $S$ \pscmt{???}.  
%

%-------------------------------------------------------------------------------
\subsection{Abstract Deduction Transformers} \label{sec:abst}
%-------------------------------------------------------------------------------

To make our algorithm efficient, we have to focus abstract
transformers on performing only the minimally necessary
work. 
%
We thus define a specialised variant of the transformer to compute
deductions w.r.t.\ a given subdomain $\subdomain\subseteq \domain$.
A subdomain contains a chosen subset of the elements in $\domain$ including $\bot$ and $\top$.
\[\abstrans{\domain}{\constraint}^\subdomain(\absval)=\absval\meet_\domain \alpha_\subdomain(\{\val\mid \val\models \constraint\})\]
For $\subdomain=\domain$, the abstract transformer behaves in the same way as the one defined in Section~\ref{sec:domains}.
%
The restriction to a subdomain makes it less precise. Therefore, we have the property $\abstrans{\domain}{\constraint}^\domain(\absval)\sqsubseteq \abstrans{\domain}{\constraint}^\subdomain(\absval)$.
%
\pscmt{explain $\makesubdomain(Vars)$}
For example, for
$\absval=(0\leq y \leq 1 \wedge 5\leq z)$ we have
$\abstrans{\domain}{x=y+z}^{\makesubdomain(\{x\})}(\absval)=(x\geq 6)$, whereas
$\abstrans{\domain}{x=y+z}^{\makesubdomain(\{y,z\})}=\top$.
%
The advantage of this definition is that with the help of $\subdomain$
we can now control how we propagate within our constraint system.
%
For the example above, $\subdomain=\makesubdomain(\{x\})$ performs a
right-hand side to left-hand side propagation and hence emulates a
forward analysis on the input program; whereas with
$\subdomain=\makesubdomain(\{y,z\})$) we emulate a backward analysis.
%
We call the propagation with $\subdomain=\domain$ \emph{multi-way
  propagation}, which simultaneously performs forward and backward
propagation.

%Moreover, we want to know what the reasons for a specific deduction are.
%\[ded(s,a,L)=\{R\rightarrow d\mid R=reasons(s,a,L,d), d \in decomp(\llbracket s \rrbracket^\sharp(a,L))\}\]
%where 
%$reasons(s,a,L,d)=\text{argmin}_{R\in\{R'\mid R'\subseteq decomp(a), \llbracket s\rrbracket^\sharp(R,L)=d\}} |R| $.

\pscmt{give an example for $ded$, link it to the reason trail}

\pscmt{define $ded$ for all statements, connect this to worklist}

\pscmt{link livevars to $L$ -- the subdomain spanned by livevars}

%-------------------------------------------------------------------------------
\subsection{Algorithm for Deduction Phase}
%-------------------------------------------------------------------------------
%
\rmcmt{Talk about lazy closure operation}

\pscmt{
Rough and sketchy:
%
$espan(V)=$all meet irreducibles $\in A$ that contain at most one variable that is not in $V$.
%
$select(S,PV)$ is the set of statements that contain variables in $PV$ where $PV$ is the set of variables in the previous deduction.
%
$LV(s)$ are the live variables of a statement $s$, i.e.\ the intersection of $PV$ with the variables in $s$.
\begin{theorem}
$$
\gfp\lambda a. \bigsqcap_{s\in S} ded(s,a,A) = 
\gfp\lambda a. \bigsqcap_{s\in select(S,PV)} ded(s,a,espan(LV(s)))
$$
\end{theorem}
Proof sketch: see Appendix
}

Algorithm~\ref{Alg:ms} presents the deduction phase in abstract model
search procedure. \pscmt{The propagation heuristics $H$ provides two
  functions $\initworklist$ and
  $\updateworklist$. Describe them for the different
  heuristics (already done for initialize, TBD for update...}
A {\em worklist} is a queue which contains \rmcmt{abstract deduction
transformers}.  A {\em worklist} is initialized following a heuristics 
choice for propagation strategies. A {\em forward} propagation strategy 
initializes the worklist with \rmcmt{abstract} transformers that 
has constants in the right-hand side. Whereas, a {\em backward} 
iteration strategy starts with a set of assertions. On the other hand, a 
{\em multi-way} iteration strategy initializes the worklist with set of all 
transformers and performs both forward and backward propagations in tandem.  
For every meet irreducible deduction transformer \pscmt{rename} $s \in S$ 
passed to the abstract domain, if the domain infers a new meet irreducible 
$\mathit{meet\_irrd}$, it is added to $\trail$ \pscmt{It usually infers several ones.}.  Additionally, the reason 
trail $\reasons$ \pscmt{define} is updated with the transformer $s$ as the reason for inferring
$\mathit{meet\_irrd}$. If a conflict is deduced, that is, $\mathit{meet\_irrd} = \bot$ 
is inferred by the domain, the algorithm terminates with \textsf{conflict}.  However,
when a fixed-point is reached, the abstract valuation $v$ is checked for set of
models.  This is determined by checking whether the set of assignments in $v$ is 
$\gamma$-complete~\cite{dhk2013-popl}. If $v$ is $\gamma$-complete, that is, the 
abstract valuation $v$ is abstractly satisfying, the abstract model 
search terminates with \textsf{sat}.  Otherwise, the algorithm returns \textsf{unknown} and the 
model search procedure makes a new decision.    



