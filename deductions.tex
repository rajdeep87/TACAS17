\section{Deduction}
\begin{definition}{(Abstract Deduction Transformer)} An abstract deduction
transformer, $\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
domain $A$ is a sound approximation of a concrete model transformer
$ded_{\varphi}$, given by $\widehat{ded_{\varphi}} : A \rightarrow A$, such that 
$\forall a \in A: \widehat{ded_{\varphi}}(a) \in \{\top, \bot, m\}$, where 
$m \in A$ is a meet irreducible.   
\end{definition}

Let us consider a formula $\varphi = (x:=y-1)$ to be analyzed over 
an interval abstract domain, $A = ItvDom$, and let $a = \langle y:[3, 5]
\rangle \in ItvDom$, then $\widehat{ded_{\varphi}}(a) = a \meet \langle x:[2, 4]
\rangle$.  An abstract deduction transformer is typically computed in the form 
of strongest post-condition or a weakest pre-condition of a formula in the 
abstract domain.    

A meet decomposition of the outcome of abstract deduction transformer 
is obtained by taking a meet of the element $\langle y:[3, 5] \rangle, 
\langle x:[2, 4] \rangle \in ItvDom$ which gives set of meet irreducibles, 
$\{ \langle y \succeq 3 \rangle, \langle y \preceq 5 \rangle, 
\langle x \succeq 2 \rangle, \langle x \preceq 4 \rangle \}$, that are 
precisely complementable.

\begin{definition}{(Meet Decomposition)} A meet decomposition of an abstract
element $a \in A$ is a set of meet irreducibles $M \subseteq A$ such that 
$\forall m_i \in M, \meet(m_i) = a$, where $max(i) = |M|$.
\end{definition}
 
For a program with $N$ variables, let $L$ be the total number of 
meet irreducibles returned by a domain $D$.  For $D$ = {\em ItvDom}, the 
maximum value of $L$ is $2*N$, whereas the maximum value of $L$ is 
$2*(N^2)$ for $D$ = {\em OctDom}. Note that an octagon is the conjunction 
of all octagonal inequalities in the set $L$.
%
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagon \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++;
 assert(x==y+1);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
SSA &\iff& ((guard0 == TRUE) \land \\
    &    & (cond == (x == y)) \land \\
    &    & (guard1 == (cond \&\& guard0)) \land \\
    &    & (x' == 1u + x) \land \\
    &    & (x' == 1u + y || !guard1))
\end{array}$
\end{minipage}
&
\begin{minipage}{3.75cm}
$\begin{array}{l@{\,\,}c@{\,\,}l}
C &\iff& ((x' > 1) \land (-x'-y < -2) \land \\
  &    & (-x-x' < -2) \land (y-x' < 0) \land \\                                                                
  &    & (x-x' < 0) \land (y > 0) \land \\
  &    & (x > 0) \land (-x'-y < 0) \land \\
  &    & (x+y > 1) \land (y-x < 1) \land \\
  &    & (x'-y < 2) \land (x-y < 1) \land \\
  &    & (x+y > 0) \land (x+x' > 0) \land \\
  &    & (x'-x < 2))
\end{array}$
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal Inequalities}
\label{swssa}
\end{figure}
%
\subsection{Algorithm for Deduction}

\subsection{Forward Iteration Strategy}
For forward iteration on Figure~\ref{swssa}, we need atleast 
one decision to deduce BOTTOM and prove safety. The deduction 
happens from right to left in forward iteration strategy.

The initialization of live variable and subsequent update depends on the iteration strategy.

\subsection{Backward Iteration Strategy}

\subsection{Chaotic Iteration Strategy}  
The set of octagonal equilities corresponding to Figurei~\ref{sw-ssa}
is shown below. For chaotic, no decision is required to deduce BOTTOM.

\Omit {
Let us consider an example. 
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & SSA & Octagons \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
int id(int a) {
  return a;
}
int main() {
 int x,y,z;
 _Bool c;
 if (c)
   x = -1;
 else
   x = 2;
 int k = id(x);
 z = x * k;
 assert((z!=-2));
}
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true,language=C]
cond == (x == y)
guard1 == (cond19 && guard0)
x' == 1u + x
x' == 1u + y || !guard1
guard0 == TRUE
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true,language=C]

\end{lstlisting}
\\
\hline
\end{tabular}
\caption{C Program, corresponding SSA and Octagonal inequalities}
\label{swssa}
\end{figure}
}

With forward iteration strategy using octagon domian, the program 
is proved without any decision. However, with the forward strategy
using interval domain, we just required one decision to prove the program. 
