\section{Preliminaries}
This section introduces the program model and identifies properties of abstract
domains that are necesary for learning in abstract lattice structures.
% \subsection{Programs:}
% %
% A {\em program} $\mathcal{P}$ is formally defined as follows.
% \[
% \begin{array}[t]{@{}lll}
% \mathcal{P} & {:}{:}{=} & \mathit{Procedure} \\
% \mathit{Procedure} & {:}{:}{=} & \mathit{Statement} \mid \mathit{Procedure} \\
% \mathit{Statement} & {:}{:}{=} & CStatement \mid \mathit{function(Var_1,\dots,Var_n)} \\
% \mathit{CStatement} & {:}{:}{=} & x {:}{=} exp \mid \mathit{ITE}(b, s_1,s_2) \mid \mathit{s_1;s_2} \mid loop\{s\} \\
% \end{array}
% \]
% Consider sets of expressions $Exp$ and Boolean expressions $BExp$
% over variables $Var$ of $\mathcal{P}$.  The variables in $Var$ 
% can take numeric values in $Val$.  A procedure is denoted as 
% $\mathit{function(Var_1,\dots,Var_n)}$.  A $\mathit{CStatement}$ 
% is an assignment, conditional, sequential concatenation or a loop. \\
% \textbf{Control-flow Graph:} A CFG is a triple $(Loc, E, lbl)$, 
% where $Loc$ is the set of locations with an unique start 
% location $(init)$ and error location $(err)$, $E$ is the set 
% of control-flow edges that are labelled with the set 
% $lbl \in Statement$.  For the purpose of illustration, we 
% assume that all the procedures are inlined.  

%-------------------------------------------------------------------------------
\subsection{Program Representation}  
\Omit {
\begin{wrapfigure}{r}{3cm}
\[
\begin{array}{rcl}
g_0 &=& \true \\
\multicolumn{3}{l}{0 \leq v\leq N} \\
g_1 &=& g_0\wedge c\\
x_0 &=& v \\
x_1 &=& -v \\
x_2 &=& g_1?x_0:x_1 \\
g_2 &=& g_1 \vee g_0\wedge \neg c\\
z &=& x_2 * x_2 \\
\multicolumn{3}{l}{z<0 \wedge g_2}
\end{array}
\]
\caption{\label{fig:ssa}
SSA for the example in Figure~\ref{fig:example}
}
\end{wrapfigure}
}
\begin{figure}[t]
\center
\scriptsize
\begin{tabular}{l|l}
\hline
 SSA & Abstract Conflict Graph \\
\hline
\begin{minipage}{4.50cm}
$\begin{array}{rcl}
\mathcal{P}:= (g_0 = \true) \wedge (c = 0 \leq v\leq N) \\
(g_1 = g_0 \wedge c) \wedge (x_0 = v) \wedge \\
(x_1 = -v) \wedge (x_2 = g_1?x_0:x_1) \wedge \\
(g_2 = g_1 \vee g_0\wedge \neg c) \wedge \\
(z  = x_2 * x_2) \wedge (z<0 \wedge g_2)
\end{array}$
\end{minipage}
&
\begin{minipage}{5.2cm}
\centering
\scalebox{.45}{\import{figures/}{learning.pspdftex}}
\end{minipage}
\\
\hline
\end{tabular}
\caption{SSA and abstract conflict graph}
\label{ssa}
\end{figure}
%
We consider programs with bounded loops 
%(respectively bounded unwindings of programs with loops or recursion) with 
containing safety properties given as assertions in the code.
%
Such a program is represented as set $\mathcal{P}$ of
\emph{statements} $s$.  These are constraints as typically obtained by
translating the program into single static assignment (SSA) form via a
data flow analysis.
%
Figure~\ref{ssa} shows the SSA constraints for the program in figure~\ref{fig:example}. 
%
Assignments such as \texttt{x=v;} become equalities $x_1=v$ where the
left-hand side variable gets a fresh name (subscript).
%
Control flow is encoded into guard variables such as $g_1=g_0\wedge c$.
%
Data flow joins become conditional expressions, e.g.\ $x_3=g_1?x_1:x_2$.
%
Assertions $\mathcal{A}$ are constraints $a$ of the form $g_3
\Rightarrow z\geq 0$, meaning that if $g_3$ holds (i.e.\ the assertion
is reachable) then the assertion must hold.
%
%
%
%For example, figure~\ref{swssa} presents the program analysis constraints for 
%a C program in Static Single Assignment (SSA) form.  

% \subsection{Concrete Semantics}
% \pscmt{not sure that adds anything for TACAS}
% The {\em concrete} domain is a lattice 
% of concrete environments, $Env = Var \rightarrow Val$, and is 
% defined by $CDom = (Env, \sle_{C}, \join_{C}, \meet_{C})$.
% A transformer, $post_{stmt}$, of concrete domain defines 
% the effect of a statement $stmt$ on the concrete domain, 
% $post_{stmt} : \powerset(Env) \rightarrow \powerset(Env)$.  
% 
% A state in concrete domain is a tuple $\langle l, \sigma \rangle$, 
% where $l$ is a location and $\sigma \in Env$.  A trace is a sequence 
% of states $(l_0, \sigma_0), \ldots (l_n, \sigma_n)$ such that for all 
% $0 \leq i \leq n$, there exists a cfg egde $(l_{i}, l_{i+1})$ 
% if $\sigma_{i+1} \in post_{i}(\sigma_{i})$. 

%-------------------------------------------------------------------------------
\paragraph{Safety problem}  
%
Based on above program representation, the safety problem solved by the ACDCL solver is the following:
%
\begin{equation}\label{eq:safety}
\varphi:= \bigwedge_{s\in\mathcal{P}} s \wedge \neg \bigwedge_{a\in\mathcal{A}} a
\text{ is unsatisfiable if and only if the program is safe.}
\end{equation}

% \subsection{Static Analysis Equations for Safety}
% Static program analysis based on abstract interpretation~\cite{DBLP:conf/emsoft/Cousot07} 
% perform safety analysis by computing fixed point to infer invariants 
% over program variables.  However, bounded model checking (BMC) tries to search 
% for a counterexample in a bounded execution trace, by symbolically executing a 
% program up to a finite bound.  
% Similar to BMC, ACDCL searches for a counterexample by solving the formula shown below.
% For a set $N$ of program analysis constraints defined over a set 
% of constraint variables $Var = \{X_i| i \in N\}$, representing a program
% $\mathcal{P}$ and a concrete domain $\powerset(Env)$, the static analysis equation 
% for safety of $\mathcal{P}$ is given as follows.  Here, $X_{init}, X_{Err}$ denote the initial valuation 
% and the \rmcmt{final valuation} of constraint variables.
% \[\varphi = X_{init} \subseteq Env \wedge \underset{p,q \in |\mathcal{P}|}
% {\bigwedge} \{ X_p \subseteq post_{(p,q)}(X_q) \} \wedge X_{err} \supset \emptyset \] 

%-------------------------------------------------------------------------------
\subsection{Abstract Domain}
%-------------------------------------------------------------------------------
The work of~\cite{sas12,dhk2013-popl} shows that CDCL based SAT solvers 
operates on the partial assignment domains. We present a generic instantiation 
of CDCL architecture that can be extended to any relational and non-relational
domains.  
% 
In our prototype implementation and for illustrative purposes in this
paper we use a product domain $\mathcal{B}^b\times\mathcal{R}$ where
$\mathcal{B}$ is the Boolean domain
$\langle\{\true,\false,\bot,\top\},\Rightarrow,\wedge,\vee\rangle$, 
$b$ is the number of Boolean variables in the program, 
and $\mathcal{R}$ is a \emph{relational} domain over the 
numerical (bitvector) variables in their respective
data types (currently, signed and unsigned integers are supported).
%
We instantiate $\mathcal{R}$ with the template polyhedra domain.

For notational convenience we will denote elements of
$\mathcal{B}^b$ by their concretisations to propositional formulae,
e.g.\ for the Boolean variable vector $(g_1,c)$ with abstract value
$(\false,\top)$ we will write $\neg g_1$.

%-------------------------------------------------------------------------------
\paragraph{Template Polyhedra Abstract Domain}
%
The template polyhedra domain~\cite{sriram} represents sets $X$ of
valuations of a vector of variables $\vec{x}$ such that
$\mat{C}\vec{x}\leq\vec{d}$ for a fixed coefficient matrix $\mat{C}$
and a constant vector $\vec{d}$. The domain of $\vec{d}$ is augmented
by a special element to denote the minimal element $\bot$ of the lattice.
%
The abstraction function is defined as $\alpha(X) = \min \{\vec{d}\mid
\mat{C}\vec{x}\leq\vec{d}, \vec{x}\in X\}$ where $\min$ is
applied component-wise. There are several optimisation-based
techniques for computing the domain
operations~\cite{sriram,GS07b,BJKS15}. In our implementation we use
the strategy iteration approach available in 2LS~\cite{BJKS15}.
%
The concretisation $\gamma(\vec{d})$ is the set $\{\vec{x}\mid
\mat{C}\vec{x}\leq\vec{d}\}$; $\gamma(\bot)=\emptyset$.
%
For notational convenience we will use conjunctions of linear
inequalities, e.g.\ $x_1\geq 0 \wedge x_1-z\leq 30$ to denote elements
of the domain. $\true$ is $\top$ and $\false$ is $\bot$.

% \paragraph{Interval Abstract Domain} 
% The {\em Interval} abstract domain is a lattice 
% $ItvDom = (ItvElm, \sle_{I}, \join_{I}, \meet_{I})$, where
% $ItvElm: (Var \rightarrow Itv) \cup \{\bot\}$, and $Itv$ is 
% the set of intervals of type $[l,u]$ over numeric data 
% type with $l \leq u$. The least element is $\bot$ and the 
% greatest element is $\top$ which maps all variables to their
% minimum ($min$) and maximum ($max$) values.  An interval 
% $\langle x, [min, v] \rangle$ is written as $x \leq v$.  The 
% partial order $\sle_{I}$ over elements in the set $Itv$ is 
% given by $I_1 \sle_{I} I_2$ if $I_2$ contains $I_1$.
% A join $(\join_{I})$ of two intervals $\langle x_1 \rightarrow [l_1, u_1], 
% x_1 \rightarrow [l_2, u_2] \rangle$ is an interval 
% $\langle x_1 \rightarrow [min(l_1, l_2), max(u_1, u_2)]$.
% A meet $(\meet_{I})$ of two intervals $\langle x_1 \rightarrow [l_1, u_1], 
% x_1 \rightarrow [l_2, u_2] \rangle$ is an interval 
% $\langle x_1 \rightarrow [max(l_1, l_2), min(u_1, u_2)] \rangle$.
% The galois connection between the concrete environment and intervals is 
% given as follows.
% \[\alpha(x) = \{[inf(x), sup(x)] | x \in Var\} \qquad   \alpha(\emptyset) = \bot \]
% \[\gamma[p,q] = \{c \in \mathbb{Z} | p \leq c \leq q\} \qquad \gamma(\bot) = \emptyset \]
Template polyhedra subsume, for example, interval and octagon domains.

\begin{wrapfigure}{r}{4.5cm}
\vspace*{-3ex}
\scalebox{.65}{\import{figures/}{octagons.pspdftex}}
\caption{Example of an octagon}\label{octagon}
\vspace*{-3ex}
\end{wrapfigure} 

For a program with $N$ variables, the matrix $\mat{C}$ for intervals
generates at most $2N$ inequality constraints, one for the upper and lower
bounds of each variable.
%
For octagons, we have at most $2N^2$ inequalities, one for the upper
and lower bounds of each variable and sums and differences for each
pair of variables. Figure~\ref{octagon} shows an 
example octagon and its associated inequalities.   

The interval domain is a non-relational domain because a single
inequality only contains a single variable.
%
The octagon domain, however, is relational.  A fundamental difference
between relational and non-relational domains is that relational
domains require the computation of a \emph{closure} in order to obtain
a normal form that is usually required for efficient domain operations.
An example of a closure computation is shown below.
\[\mathit{closure}((x-y \leq 4) \wedge (y-z \leq 5))=((x-y \leq 4) \wedge (y-z \leq 5) \wedge (x-z \leq 9)) \]  
The closure computes all implied domain constraints.  For octagons,
the closure operation is very expensive (cubic complexity in the
number of program variables).
%
We will see that our algorithm performs closure computations lazily,
postponing them to the point where they are actually necessary.

% \paragraph{Octagon Abstract Domain} \pscmt{TODO: simplify}
% The {\em Octagon} abstract domain is a lattice 
% $OctDom = (OctElm, \sle_{O}, \join_{O}, \meet_{O})$, where
% $OctElm: (Var \times Var \rightarrow (\mathbb{R} \cup \{\infty\})) \cup \bot$. 
% The least element is $\bot$ that contains all unsatisfiable 
% set of inequalities and the greatest element is $\top$ which 
% maps the bounds of all octagonal inequalities to $\infty$. 
% The partial order $\sle_{O}$ over elements in the set $OctElm$ is 
% given by $O_1 \sle_{O} O_2$ iff the bounds of each inequalities in $0_1$ 
% is included (by $\leq$ order) in the bounds of corresponding inequalities 
% in $O_2$, that is, the octagons are ordered by the inclusion relations.

% The join $(\join_{O})$ of two octagons, $\langle (v_i \times v_j \rightarrow N_1),
% (v_i \times v_j \rightarrow N_2) \rangle$, is not necessarily an octagon 
% and is computed by taking piece-wise maximum of bounds of corresponding 
% octagonal inequalities, $\langle (v_i \times v_j \rightarrow max(N_1, N_2) \rangle$.
% However, the meet $(\meet_{O})$ of two octagons, $\langle (v_i \times v_j \rightarrow N_1),
% (v_i \times v_j \rightarrow N_2) \rangle$, is always an octagon and is 
% computed by taking piece-wise minimum of bounds of corresponding 
% octagonal inequalities, $\langle (v_i \times v_j \rightarrow min(N_1, N_2)$.  A closed 
% octagon is the smallest octagon following the partial order $\sle_{O}$, among all 
% the octagons that abstract the same concrete values.

% The octagon domain is a relational abstract domain that permits $2n^2$ 
% linear inequalities between $n$ program variables.  The octagonal 
% inequalities are of two types: binary or unary inequalities as shown below.
% \[Binary: \pm v_i \pm v_j \leq a, v_i \neq v_j \qquad Unary: v_i \leq b, \{a, b\} \in \mathbb{R} \cup \infty \]  
% An element in octagon domain, $OctElm$, is a conjunction of such 
% inequalities and is called an octagon.  
%
% For building program analyzers using octagon domains, the domain also 
% provides few operators like {\em widening ($\nabla$)} and {\em closure ($*$)}.  
% The widening operator is used to accelerate convergence for loops in the program
% and has a quadratic complexity in the number of variables.  If the bound of an 
% octagonal inequality increases every iteration, then $\nabla$ sets the bounds 
% to $\infty$.  However, the closure operator is often used to reduce the degree 
% of over-approximation resulting from the join operation. 

% \begin{definition}{(Abstract Valuation)} An {\em abstract valuation} is a
% mapping of variables to an element of abstract domain, for example 
% a mapping of variable $x$ to an interval environment is given by 
% $\langle x \mapsto [2,5] \rangle$ or a mapping of $\{x,y\}$ to octagon 
% environment is given by $\langle x-y \mapsto 0, y-x \mapsto 0 \rangle$.  
% An abstract valuation is {\em atomic} if each variable is mapped to a singleton 
% value or to $\bot$.  
% \end{definition}

%-------------------------------------------------------------------------------
\paragraph{Abstract Transformers}
%
%In a typical abstract interpretation based Galois-connection setting
%over an over-approximate domain, every concrete element has a unique
%over-approximate representation in the abstract.  Likewise, every
%concrete transformer is over-approximated by a unique abstract
%transformer.  We now define an abstract deduction transformer.
%
An abstract transformer transforms an abstract value $a$ through a
statement $s$, i.e.\ it \emph{deduces} information from $a$ and $s$.
The best abstract transformer is
\[\llbracket s
\rrbracket^\sharp(a)=\bigsqcup \{a'\mid a'\models s\}\] where we write
$a\models s$ if $\forall \vec{y}\in\gamma(a): (s[\vec{y}/\vec{x}]
\equiv \true)$, i.e.\ the constraint $s$ is valid when evaluated over
all values $\vec{y}$ of its variables $\vec{x}$ in the concretisation
of $a$. Any abstract transformer that over-approximates the least
upper bound is a sound transformer and can be used in our algorithm.

In a forward analysis, we can deduce, for example, $\llbracket
x=2(y+z)\rrbracket^\sharp(a)=(-2\leq x\leq 6)$ for $a=(0\leq y \leq 2
\wedge 1 \leq y-z \leq 1)$.
%
We will give more details in Section~\ref{sec:abst}.

%-------------------------------------------------------------------------------
\subsection{Properties of Abstract Domains}
%-------------------------------------------------------------------------------
%
An important property of a clause learning SAT solver is that each
non-singleton element of the partial assignment domain can be 
decomposed into a set of precisely complementable singleton elements.  
This property of the partial assignment domain is required to learn 
elements that help to guide the model search away from the
conflicting region of the search space.  Complementation operator 
in abstract domains is different from the notion of precise complements. 
%
Most numerical abstract domains, such as intervals and octagons lack
complements, but they can be represented as intersections of
complementable half-spaces, each of which has a complement. 
%
% We identify specific properties of domain elements necessary for 
% abstract model search and learning in abstractions.  
We formalise this in the sequel.
%
\begin{definition} 
A \emph{meet irreducible} $m$ in a complete lattice 
structure $A$ is an element with the following property.
\[\forall m_1, m_2 \in A: m_1 \meet m_2 = m \implies (m = m_1 \lor m = m_2), m \neq \top \]  
%\rmcmt{mention minimum complementable element}
\end{definition}
%
The meet irreducibles in the boolean domain $\mathcal{B}$ for a variable $x$ are 
$x$ and $\neg x$. The meet 
irreducibles in the template polyhedra domain are all elements 
that concretise to half-spaces, i.e.\ they can be represented 
by a single inequality. For the interval domain, these are 
\ $x \leq d$ or $x \geq d$ for constants $d$. 

%An important property of meet irreducibles in case of partial assignments 
%domain is that they have precise complements.  
%For example, the complement of $\{x \mapsto true \}$ is a 
%singleton element,$\{x \mapsto false \}$, in the partial assignments domain. 

\begin{definition}
A \emph{meet decomposition} $\mathit{decomp}(a)$ of an abstract
element $a \in A$ is a set of meet irreducibles $M \subseteq A$ such that 
$a=\bigsqcap_{m\in M} m$.
%$forall m_i \in M, \meet(m_i) = a$, where $max(i) = |M|$.
\end{definition}

For polyhedra this intuitively means that each polyhedron can be
written as an intersection of half-spaces.
%
For example, the meet decomposition of the interval domain element
% $(x,y) \in [2,4]\times[3, 5]$ 
$decomp(2\leq x\leq 4 \wedge 3\leq y\leq 5)$ is
the set $\{x\geq 2, x\leq 4, y\geq 3, y\leq 5\}$.
% \langle x:[2, 4] \rangle \in ItvDom$ which gives set of meet irreducibles, 
% $\{ \langle y \succeq 3 \rangle, \langle y \preceq 5 \rangle, 
% \langle x \succeq 2 \rangle, \langle x \preceq 4 \rangle \}$, that are 
% precisely complementable.

\begin{definition} 
An element $a\in A$ is called \emph{precisely complementable}
iff $\exists \bar{a} \in A: \neg\gamma(\bar{a})=\gamma(a)$, 
i.e.\ there is an element whose negated concretisation equals
the concretisation of $a$.
%m\meet\bar{m}=\bot \wedge m\join\bar{m}=\top$.
%A complementable meet irreducible $\bar{M}$ of an abstract lattice $A$ is the complement of a meet 
%irreducible $M \in A$ such that $\bar{M} \in A$ and the concretisation of $M$ 
%is the set complement of $\bar{M}$.  
%If every meet irreducible in $A$ is complementable, then $A$ is said to
%be have complementable meet irreducibles.
\end{definition}

% An important property of a clause learning SAT solver 
% is that a partial assignments domain can be decomposed 
% into a set of precisely complementable singleton assignments.  
% This property of the partial assignments domain helps to 
% guide the model search away from the conflicting region 
% of the search space and allows case-based analysis.  Complementation 
% operator in abstract domains is different from the notion of precise
% complements. 
%
% \begin{definition}{(Precise complement)} Let $A$ be an lattice. A precise 
% complement of an abstract element $a \in A$ is an element $\bar{a} \in A$ 
% such that the negation of concretization $(\gamma)$ of $a$ is equivalent to 
% concretization of $\bar{a}$, that is, $\gamma(\bar{a}) = \neg \gamma(a))$.
% \end{definition}
%
The precise complementation property of partial assignment lattice 
can be generalized to other lattice structures.  Most numerical 
abstract domains, such as intervals, octagons, polyhedra, can be 
decomposed into half-spaces, that admits precise complements.  
For example, a precise complement of a meet irreducible $(x \leq n)$ 
in interval domain is $(x > n)$, or a meet irreducible $(x+y < 1)$ in 
octagon domain is $(-x-y < 0)$.  Our template-based domain implementation 
precisely complements a meet irreducible in an abstraction.
\Omit{
Numerical abstract domains that admit complementable decomposition 
are shown in Figure~\ref{fig:complement}.  
}
% 
\Omit{
\begin{table}
\begin{center}
{
\begin{tabular}{l|l}
\hline
Domain & Precise Complements \\ \hline 
Interval & \((x \leq n) \quad \longrightarrow (x > n)\) \\ \hline
Octagon & \((x+y < 1) \quad \longrightarrow (-x-y < 0)\) \\ \hline
Equality & \((x==y) \quad \longrightarrow (x \neq y)\) \\ \hline 
\end{tabular}
}
\end{center}
\label{fig:complement}
\end{table}
}
%
\Omit {
Note that for many domains $A$ including template polyhedra
most domain elements are not precisely complementable within $A$.
%
In fact, for template polyhedra all non-meet-irreducible elements $e$
(except $\bot$ and $\top$) are not precisely complementable,
whereas all meet irreducibles are precisely complementable.
%
Hence, we can complement each element in the meet decomposition of $e$ and
re-interpret the obtained set as a disjunction. 
%
%Thus the complement of the octagon in Figure~\ref{octagon} 
%can be written as a disjunction of meet irreducibles:
%\[(x{\leq} -3) \lor (x{\geq} 2) \lor (y{\leq} -2) \lor (y{\geq} 3) \lor (x+y{\geq} 3) \lor (x-y{\geq} 2) \lor (y-x{\geq} 4) \lor (-x-y{\geq} 3)\]
}
Standard abstract interpretation does not require a complementation
operator. Hence, abstract domain libraries, such as APRON~\cite{apron}
do not provide it.  However, it can be implemented with the help of a
meet decomposition as explained above.
%
%Another feature that abstract domain libraries do not provide is to
%track the reasons why certain deductions have been made. We come back
%to this point in Section~\ref{sec:abst}.

% The abstract transformer, $apost_{stmt}$, captures the effect of different program 
% statements in the abstract domain. The transformer is precise for octagonal 
% assignments $(x:=y+1)$ but imprecise for non-octagonal assignments $(x:=y+z)$, 
% as shown below.
% \[apost_{x:=y+1}(a) = b = \langle x-y \leq 1, y-x \leq 1 \rangle \qquad apost_{x:=y+z}(b) = \langle \top \rangle \]  

% \begin{definition}{(Abstract Deduction Transformer)} An abstract deduction
% transformer, $\widehat{ded_{\varphi}}$ for a formula $\varphi$ over an abstract 
% domain $A$ is a sound approximation of a concrete model transformer
% $ded_{\varphi}$, given by $\widehat{ded_{\varphi}} : A \rightarrow A$, such that 
% $\forall a \in A: \widehat{ded_{\varphi}}(a) \in \{\top, \bot, m\}$, where 
% $m \in A$ is a meet irreducible.   
% \end{definition}

% Let us consider a formula $\varphi = (x:=y-1)$ to be analyzed over 
% an interval abstract domain, $A = ItvDom$, and let $a = \langle y:[3, 5]
% \rangle \in ItvDom$, then $\widehat{ded_{\varphi}}(a) = a \meet \langle x:[2, 4]
% \rangle$.  An abstract deduction transformer is typically computed in the form 
% of strongest post-condition or a weakest pre-condition of a formula in the 
% abstract domain.  

% For a program with $N$ variables, let $L$ be the total number of 
% meet irreducibles returned by a domain $D$.  For $D$ = {\em ItvDom}, the 
% maximum value of $L$ is $2*N$, whereas the maximum value of $L$ is 
% $2*(N^2)$ for $D$ = {\em OctDom}. Note that an octagon is the conjunction 
% of all octagonal inequalities in the set $L$.
%
%========================
%\input{literals-clauses}
%========================

\Omit{
%
}
% \Omit {
% The commonly used library for numerical abstract domains  
% is the APRON C library~\cite{apron}.  This library is 
% used for the static analysis of the numerical variables 
% of a program by abstract interpretation. APRON provides a 
% C API interface to various abstract domains and libraries 
% such as {\em BOX}, {\em OCTAGON}, {\em Convex Polyhedra} and
% {\em Linear Equalities} library.  The aim of such analysis is 
% to compute invariants over numerical variables in the 
% program~\cite{se2011}. 
% }
% \Omit {
% To this end, we implement our own template-based polyhedra domain and interval 
% domain which supports complementation operator.  
% %For example, the octagon in Figure~\ref{octagon} can be written as a conjunction of:
% %\[(x>=-2) \land (x<=1) \land (y>=-1) \land (y<=2) \land (x+y<=2)
% %\land (x-y<=1) \land (y-x<=3) \land (-x-y<=2)\] 
% \pscmt{That's no valid motivation. We never complement a whole octagon, but just a
%  meet-irreducible. It's trivial to do that with APRON. The reason was
% a different one: APRON does not support all C operators, e.g. the bitwise
% operators.} 
% } 

