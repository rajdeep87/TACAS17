\section{Program and Abstract Domains}
In this section, we define a notion of program analysis constraints, concrete
domain and abstract domain. \\
\Omit {
\subsection{Programs:}
%
A {\em program} $\mathcal{P}$ is formally defined as follows.
\[
\begin{array}[t]{@{}lll}
\mathcal{P} & {:}{:}{=} & \mathit{Procedure} \\
\mathit{Procedure} & {:}{:}{=} & \mathit{Statement} \mid \mathit{Procedure} \\
\mathit{Statement} & {:}{:}{=} & CStatement \mid \mathit{function(Var_1,\dots,Var_n)} \\
\mathit{CStatement} & {:}{:}{=} & x {:}{=} exp \mid \mathit{ITE}(b, s_1,s_2) \mid \mathit{s_1;s_2} \mid loop\{s\} \\
\end{array}
\]
Consider sets of expressions $Exp$ and Boolean expressions $BExp$
over variables $Var$ of $\mathcal{P}$.  The variables in $Var$ 
can take numeric values in $Val$.  A procedure is denoted as 
$\mathit{function(Var_1,\dots,Var_n)}$.  A $\mathit{CStatement}$ 
is an assignment, conditional, sequential concatenation or a loop. \\

\textbf{Control-flow Graph:} A CFG is a triple $(Loc, E, lbl)$, 
where $Loc$ is the set of locations with an unique start 
location $(init)$ and error location $(err)$, $E$ is the set 
of control-flow edges that are labelled with the set 
$lbl \in Statement$.  For the purpose of illustration, we 
assume that all the procedures are inlined.  
}
\textbf{Program Analysis Constraints:}  A program $\mathcal{P}$ is represented 
as set of equations called, {\em program analysis constraints}.  The 
program analysis constraints, as shown below, is an assignment, 
or boolean expressions $BExp$ over program variables $Var$ or
a non-deterministic choice (ternary experssion) between statements $s_1$ and
$s_2$.  All the bounded loops are completely unrolled and represented using 
following constraints. Similarly, an assertion is of type $BExp$.  
\[c::= x:= exp | BExp | (exp) ? s_1, s_2\]
For example, figure~\ref{swssa} presents the program analysis constraints for 
a C program in Static Single Assignment (SSA) form.  

\pscmt{we should give the (simplified) SSA for an example here}

\subsection{Concrete Semantics}
\pscmt{not sure that adds anything for TACAS}
The {\em concrete} domain is a lattice 
of concrete environments, $Env = Var \rightarrow Val$, and is 
defined by $CDom = (Env, \sle_{C}, \join_{C}, \meet_{C})$.
A transformer, $post_{stmt}$, of concrete domain defines 
the effect of a statement $stmt$ on the concrete domain, 
$post_{stmt} : \powerset(Env) \rightarrow \powerset(Env)$.  

A state in concrete domain is a tuple $\langle l, \sigma \rangle$, 
where $l$ is a location and $\sigma \in Env$.  A trace is a sequence 
of states $(l_0, \sigma_0), \ldots (l_n, \sigma_n)$ such that for all 
$0 \leq i \leq n$, there exists a cfg egde $(l_{i}, l_{i+1})$ 
if $\sigma_{i+1} \in post_{i}(\sigma_{i})$. 

\subsection{Template Polyhedra Abstract Domain}

\pscmt{TODO} 

\paragraph{Interval Abstract Domain} \pscmt{TODO: simplify}
The {\em Interval} abstract domain is a lattice 
$ItvDom = (ItvElm, \sle_{I}, \join_{I}, \meet_{I})$, where
$ItvElm: (Var \rightarrow Itv) \cup \{\bot\}$, and $Itv$ is 
the set of intervals of type $[l,u]$ over numeric data 
type with $l \leq u$. The least element is $\bot$ and the 
greatest element is $\top$ which maps all variables to their
minimum ($min$) and maximum ($max$) values.  An interval 
$\langle x, [min, v] \rangle$ is written as $x \leq v$.  The 
partial order $\sle_{I}$ over elements in the set $Itv$ is 
given by $I_1 \sle_{I} I_2$ if $I_2$ contains $I_1$.
A join $(\join_{I})$ of two intervals $\langle x_1 \rightarrow [l_1, u_1], 
x_1 \rightarrow [l_2, u_2] \rangle$ is an interval 
$\langle x_1 \rightarrow [min(l_1, l_2), max(u_1, u_2)]$.
A meet $(\meet_{I})$ of two intervals $\langle x_1 \rightarrow [l_1, u_1], 
x_1 \rightarrow [l_2, u_2] \rangle$ is an interval 
$\langle x_1 \rightarrow [max(l_1, l_2), min(u_1, u_2)] \rangle$.
The galois connection between the concrete environment and intervals is 
given as follows.
\[\alpha(x) = \{[inf(x), sup(x)] | x \in Var\} \qquad   \alpha(\emptyset) = \bot \]
\[\gamma[p,q] = \{c \in \mathbb{Z} | p \leq c \leq q\} \qquad \gamma(\bot) = \emptyset \]
For a program with $N$ variables, there are a total of 
$2*N$ intervals. The intervals restrict the set of values 
taken by program variables at each program point, starting 
from $[-\infty, \infty]$.   

\paragraph{Octagon Abstract Domain} \pscmt{TODO: simplify}
The {\em Octagon} abstract domain is a lattice 
$OctDom = (OctElm, \sle_{O}, \join_{O}, \meet_{O})$, where
$OctElm: (Var \times Var \rightarrow (\mathbb{R} \cup \{\infty\})) \cup \bot$. 
The least element is $\bot$ that contains all unsatisfiable 
set of inequalities and the greatest element is $\top$ which 
maps the bounds of all octagonal inequalities to $\infty$. 
The partial order $\sle_{O}$ over elements in the set $OctElm$ is 
given by $O_1 \sle_{O} O_2$ iff the bounds of each inequalities in $0_1$ 
is included (by $\leq$ order) in the bounds of corresponding inequalities 
in $O_2$, that is, the octagons are ordered by the inclusion relations.

The join $(\join_{O})$ of two octagons, $\langle (v_i \times v_j \rightarrow N_1),
(v_i \times v_j \rightarrow N_2) \rangle$, is not necessarily an octagon 
and is computed by taking piece-wise maximum of bounds of corresponding 
octagonal inequalities, $\langle (v_i \times v_j \rightarrow max(N_1, N_2) \rangle$.
However, the meet $(\meet_{O})$ of two octagons, $\langle (v_i \times v_j \rightarrow N_1),
(v_i \times v_j \rightarrow N_2) \rangle$, is always an octagon and is 
computed by taking piece-wise minimum of bounds of corresponding 
octagonal inequalities, $\langle (v_i \times v_j \rightarrow min(N_1, N_2)$.  A closed 
octagon is the smallest octagon following the partial order $\sle_{O}$, among all 
the octagons that abstract the same concrete values.

The octagon domain is a relational abstract domain that permits $2n^2$ 
linear inequalities between $n$ program variables.  The octagonal 
inequalities are of two types: binary or unary inequalities as shown below.
\[Binary: \pm v_i \pm v_j \leq a, v_i \neq v_j \qquad Unary: v_i \leq b, \{a, b\} \in \mathbb{R} \cup \infty \]  
An element in octagon domain, $OctElm$, is a conjunction of such 
inequalities and is called an octagon.  Figure~\ref{octagon} shows an 
example octagon and its associated inequalities.   
%
\begin{wrapfigure}{r}{5.5cm}
\caption{An example of Octagon}\label{octagon}
\scalebox{.65}{\import{figures/}{octagons.pspdftex}}
\end{wrapfigure} 
%
For building program analyzers using octagon domains, the domain also 
provides few operators like {\em widening ($\nabla$)} and {\em closure ($*$)}.  
The widening operator is used to accelerate convergence for loops in the program
and has a quadratic complexity in the number of variables.  If the bound of an 
octagonal inequality increases every iteration, then $\nabla$ sets the bounds 
to $\infty$.  However, the closure operator is often used to reduce the degree 
of over-approximation resulting from the join operation. Closure always produces 
unique octagonal inequalities, but it is very expensive to compute because of 
cubic complexity in the number of program variables. An example of closure
operation is shown below.
\[((x-y \leq 4) \wedge (y-z \leq 5))^* \implies ((x-y \leq 4) \wedge (y-z \leq 5) \wedge (x-z \leq 9)) \]  
 
The abstract transformer, $apost_{stmt}$, captures the effect of different program 
statements in the abstract domain. The transformer is precise for octagonal 
assignments $(x:=y+1)$ but imprecise for non-octagonal assignments $(x:=y+z)$, 
as shown below.
\[apost_{x:=y+1}(a) = b = \langle x-y \leq 1, y-x \leq 1 \rangle \qquad apost_{x:=y+z}(b) = \langle \top \rangle \]  

\begin{definition}{(Abstract Valuation)} An {\em abstract valuation} is a
mapping of variables to an element of abstract domain, for example 
a mapping of variable $x$ to an interval environment is given by 
$\langle x \mapsto [2,5] \rangle$ or a mapping of $\{x,y\}$ to octagon 
environment is given by $\langle x-y \mapsto 0, y-x \mapsto 0 \rangle$.  
An abstract valuation is {\em atomic} if each variable is mapped to a singleton 
value or to $\bot$.  
\end{definition}

\begin{definition}{(Meet Irreducibles)} A {\em meet irreducible} $(M)$ 
in a complete lattice structure $A$ is a minimum complementable element 
$M \in A$ that has the following property.
\[\forall M_1, M_2 \in A, M_1 \meet M2 = M \implies (M = M_1 \lor M = M_2), M \neq \top \]  
\end{definition}

A meet irreducible in partial assignments domain are the singleton 
assignments, for example $\{x \mapsto true \}$, which represents the set 
of all propositional assignments where the literal $x$ is mapped to true.  
A meet irreducible in interval domain is $\langle x \leq n \rangle$ or 
$\langle x \geq n \rangle$.  

%
\begin{definition}{(Complementable Meet Irreducibles)} A complementable meet
irreducible $\bar{M}$ of an abstract lattice $A$ is the complement of a meet 
irreducible $M \in A$ such that $\bar{M} \in A$ and the concretisation of $M$ 
is the set complement of $\bar{M}$.  If every meet irreducible in $A$ is
complementable, then $A$ is said to be have complementable meet irreducibles.  
\end{definition}

\Omit {
An important property of meet irreducibles in case of partial assignments 
domain is that they have precise complements.  
For example, the complement of $\{x \mapsto true \}$ is a 
singleton element,$\{x \mapsto false \}$, in the partial assignments domain. 
}

%
%========================
\input{literals-clauses}
%========================

\subsection{Properties of Domain Elements for Learning}
%
\pscmt{TODO: Review by Peter}
An important property of a clause learning SAT solver 
is that each element of the partial assignments domain 
are decomposable into precisely complementable 
elements.  This property of the domain helps to guide 
the model search away from the conflicting region of the 
search space.  

Most numerical abstract domains, such as intervals, octagons, 
polyhedra lacks precise complements, but they can be 
represented as intersections of complementable half-spaces, 
each of which have precise complements.  For example, intervals 
lack complements, but the decomposition of intervals into 
meet-irreducibles have complements.  
\[x \mapsto [2,5] \mathrel{\mathop{\longrightarrow}^{\mathrm{decompose}}} \{\langle x
\geq 2 \rangle \meet \langle x \leq 5 \rangle \} \]
Similarly, the complementation of the octagon in Figure~\ref{octagon} 
can be written as disjunction of:
\[(x<-2) \lor (x>1) \lor (y<-1) \lor (y>2) \lor (x+y>2) \lor (x-y>1) \lor (y-x>3) \lor (-x-y>2)\]

Standard abstract interpretation does not require complementation property.  
Abstract Domain library, such as APRON C library~\cite{apron} is specialized 
for abstract interpretation.  We implement a template-based polyhedra domain 
that returns precise complements by decomposing it into half-spaces.    

\Omit {
The commonly used library for numerical abstract domains  
is the APRON C library~\cite{apron}.  This library is 
used for the static analysis of the numerical variables 
of a program by abstract interpretation. APRON provides a 
C API interface to various abstract domains and libraries 
such as {\em BOX}, {\em OCTAGON}, {\em Convex Polyhedra} and
{\em Linear Equalities} library.  The aim of such analysis is 
to compute invariants over numerical variables in the 
program~\cite{se2011}. 
}
\Omit {
To this end, we implement our own template-based polyhedra domain and interval 
domain which supports complementation operator.  
%For example, the octagon in Figure~\ref{octagon} can be written as a conjunction of:
%\[(x>=-2) \land (x<=1) \land (y>=-1) \land (y<=2) \land (x+y<=2)
%\land (x-y<=1) \land (y-x<=3) \land (-x-y<=2)\] 
\pscmt{That's no valid motivation. We never complement a whole octagon, but just a
  meet-irreducible. It's trivial to do that with APRON. The reason was
a different one: APRON does not support all C operators, e.g. the bitwise
operators.} 
} 
