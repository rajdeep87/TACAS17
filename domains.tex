\section{Program and Abstract Domains}
\section{Programs:}
%
A {\em program} $\mathcal{P}$ is formally defined as follows.
\[
\begin{array}[t]{@{}lll}
\mathcal{P} & {:}{:}{=} & \mathit{Procedure} \\
\mathit{Procedure} & {:}{:}{=} & \mathit{Statement} \mid \mathit{Procedure} \\
\mathit{Statement} & {:}{:}{=} & CStatement \mid \mathit{function(Var_1,\dots,Var_n)} \\
\mathit{CStatement} & {:}{:}{=} & x {:}{=} exp \mid \mathit{ITE}(b, s_1,s_2) \mid \mathit{s_1;s_2} \mid loop\{s\} \\
\end{array}
\]
Consider sets of expressions $Exp$ and Boolean expressions $BExp$
over variables $Var$ of $\mathcal{P}$.  The variables in $Var$ 
can take numeric values in $Val$.  A procedure is denoted as 
$\mathit{function(Var_1,\dots,Var_n)}$.  A $\mathit{CStatement}$ 
is an assignment, conditional, sequential concatenation or a loop. \\

\textbf{Control-flow Graph:} A CFG is a triple $(Loc, E, lbl)$, 
where $Loc$ is the set of locations with an unique start 
location $(init)$ and error location $(err)$, $E$ is the set 
of control-flow edges that are labelled with the set 
$lbl \in Statement$.  For the purpose of illustration, we 
assume that all the procedures are inlined.  

\subsection{Concrete Semantics}
The {\em concrete} domain is a lattice 
of concrete environments, $Env = Var \rightarrow Val$, and is 
defined by $CDom = (Env, \sle_{C}, \join_{C}, \meet_{C})$.
A transformer, $post_{stmt}$, of concrete domain defines 
the effect of a statement $stmt$ on the concrete domain, 
$post_{stmt} : \powerset(Env) \rightarrow \powerset(Env)$.  

A state in concrete domain is a tuple $\langle l, \sigma \rangle$, 
where $l$ is a location and $\sigma \in Env$.  A trace is a sequence 
of states $(l_0, \sigma_0), \ldots (l_n, \sigma_n)$ such that for all 
$0 \leq i \leq n$, there exists a cfg egde $(l_{i}, l_{i+1})$ 
if $\sigma_{i+1} \in post_{i}(\sigma_{i})$. 
 
\mydef{Meet Irreducible:}

\subsection{Interval Abstract Domain}
The {\em Interval} abstract domain is a lattice 
$ItvDom = (ItvElm, \sle_{I}, \join_{I}, \meet_{I})$, where
$ItvElm: (Var \rightarrow Itv) \cup \{\bot\}$, and $Itv$ is 
the set of intervals of type $[l,u]$ over numeric data 
type with $l \leq u$. The least element is $\bot$ and the 
greatest element is $\top$ which maps all variables to their
minimum ($min$) and maximum ($max$) values.  An interval 
$\langle x, [min, v] \rangle$ is written as $x \leq v$.  The 
partial order $\sle_{I}$ over elements in the set $Itv$ is 
given by $I_1 \sle_{I} I_2$ if $I_2$ contains $I_1$.
A join $(\join_{I})$ of two intervals $\langle x_1 \rightarrow [l_1, u_1], 
x_1 \rightarrow [l_2, u_2] \rangle$ is an interval 
$\langle x_1 \rightarrow [min(l_1, l_2), max(u_1, u_2)]$.
A meet $(\meet_{I})$ of two intervals $\langle x_1 \rightarrow [l_1, u_1], 
x_1 \rightarrow [l_2, u_2] \rangle$ is an interval 
$\langle x_1 \rightarrow [max(l_1, l_2), min(u_1, u_2)] \rangle$.
The galois connection between the concrete environment and intervals is 
given as follows.
\[\alpha(x) = \{[inf(x), sup(x)] | x \in Var\} \qquad   \alpha(\emptyset) = \bot \]
\[\gamma[p,q] = \{c \in \mathbb{Z} | p \leq c \leq q\} \qquad \gamma(\bot) = \emptyset \]
For a program with $N$ variables, there are a total of 
$2*N$ intervals. The intervals restrict the set of values 
taken by program variables at each program point, starting 
from $[-\infty, \infty]$.   

\subsection{Octagon Abstract Domain}
The {\em Octagon} abstract domain is a lattice 
$OctDom = (OctElm, \sle_{O}, \join_{O}, \meet_{O})$, where
$OctElm: (Var \times Var \rightarrow (\mathbb{R} \cup \{\infty\})) \cup \bot$. 
The least element is $\bot$ that contains all unsatisfiable 
set of inequalities and the greatest element is $\top$ which 
maps the bounds of all octagonal inequalities to $\infty$. 
The partial order $\sle_{O}$ over elements in the set $OctElm$ is 
given by $O_1 \sle_{O} O_2$ iff the bounds of each inequalities in $0_1$ 
is included (by $\leq$ order) in the bounds of corresponding inequalities 
in $O_2$, that is, the octagons are ordered by the inclusion relations.

The join $(\join_{O})$ of two octagons, $\langle (v_i \times v_j \rightarrow N_1),
(v_i \times v_j \rightarrow N_2) \rangle$, is not necessarily an octagon 
and is computed by taking piece-wise maximum of bounds of corresponding 
octagonal inequalities, $\langle (v_i \times v_j \rightarrow max(N_1, N_2) \rangle$.
However, the meet $(\meet_{O})$ of two octagons, $\langle (v_i \times v_j \rightarrow N_1),
(v_i \times v_j \rightarrow N_2) \rangle$, is always an octagon and is 
computed by taking piece-wise minimum of bounds of corresponding 
octagonal inequalities, $\langle (v_i \times v_j \rightarrow min(N_1, N_2)$.  A closed 
octagon is the smallest octagon following the partial order $\sle_{O}$, among all 
the octagons that abstract the same concrete values.

The octagon domain is a relational abstract domain that permits $2n^2$ 
linear inequalities between $n$ program variables.  The octagonal 
inequalities are of two types: binary or unary inequalities as shown below.
\[Binary: \pm v_i \pm v_j \leq a, v_i \neq v_j \qquad Unary: v_i \leq b, \{a, b\} \in \mathbb{R} \cup \infty \]  
An element in octagon domain, $OctElm$, is a conjunction of such 
inequalities and is called an octagon.  Figure~\ref{octagon} shows an 
example octagon and its associated inequalities.   
%
\begin{wrapfigure}{r}{5.5cm}
\caption{Am example of Octagon}\label{octagon}
\scalebox{.55}{\import{figures/}{octagons.pspdftex}}
\end{wrapfigure} 
%
For building program analyzers using octagon domains, the domain also 
provides few operators like {\em widening ($\nabla$)} and {\em closure ($*$)}.  
The widening operator is used to accelerate convergence for loops in the program
and has a quadratic complexity in the number of variables.  If the bound of an 
octagonal inequality increases every iteration, then $\nabla$ sets the bounds 
to $\infty$.  However, the closure operator is often used to reduce the degree 
of over-approximation resulting from the join operation. Closure always produces 
unique octagonal inequalities, but it is very expensive to compute because of 
cubic complexity in the number of program variables.  
 
The abstract transformer, $apost_{stmt}$, captures the effect of different program 
statements in the abstract domain. The transformer is precise for octagonal 
assignments $(x:=y+1)$ but imprecise for non-octagonal assignments $(x:=y+z)$, 
as shown below.
\[apost_{x:=y+1}(a) = b = \langle x-y \leq 1, y-x \leq 1 \rangle \qquad apost_{x:=y+z}(b) = \langle \top \rangle \]  

\subsection{Properties of Domain Elements for Decision and Learning}
One of the requirements for a clause learning SAT solver 
is that each element of the partial assignments domain 
needs to have a decomposition into precisely complementable 
elements.  This property of the underlying domain helps to 
guide the search away from the conflicting region of the 
search space.

Thus, clause learning SAT solvers requires a weak complementation property
of the abstraction.  However, numerical abstract domain,  such as 
intervals and octagons are intersections of complementable half-spaces. 
The commonly used library for numerical abstract domains  
is the APRON C library~\cite{apron}.  This library is 
used for the static analysis of the numerical variables 
of a program by abstract interpretation. APRON provides a 
C API interface to various abstract domains and libraries 
such as {\em BOX}, {\em OCTAGON}, {\em Convex Polyhedra} and
{\em Linear Equalities} library.  The aim of such analysis is 
to compute invariants over numerical variables in the 
program~\cite{se2011}. 

APRON library is specialized for the abstract interpretation 
framework which does not require complementation 
operator.  To this end, we implement our own template-based 
octagon domain which supports complementation operator.  
For example, the octagon in Figure~\ref{octagon} can be written as a conjunction of:
\[(x>=-2) \land (x<=1) \land (y>=-1) \land (y<=2) \land (x+y<=2) \land (x-y<=1) \land (y-x<=3) \land (-x-y<=2)\] 
The complementation of the above octagon can be written as disjunction of:
\[(x<-2) \lor (x>1) \lor (y<-1) \lor (y>2) \lor (x+y>2) \lor (x-y>1) \lor (y-x>3) \lor (-x-y>2)\]

