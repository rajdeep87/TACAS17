\section{Motivating Example}
%
\pscmt{you should give an example that requires a relational domain to
solve...}
\begin{figure}[t]
\scriptsize
\begin{tabular}{l|l|l}
\hline
C program & Control-Flow Graph & Abstract Conflict Graph \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
void main() {
int x,sepc=0,impl=0;
assume(x>=1 && x<=N);
spec = 2*x; 
int state = 1;
int y=x;
while(state!=0) {
 switch(state) {
  case 0: state = 1; 
  break;
  case 1: state = 2; 
  break;
  case 2: x--; y++;
  if(x == 0) state=0;
  else state=1;break;
 } 
}
impl = y;
assert(spec == impl);
}
\end{lstlisting}
&
\begin{minipage}{4.40cm}
\centering
\vspace*{0.3cm}
\scalebox{.45}{\import{figures/}{example.pspdftex}}
%\caption{A control flow graph for P, P' and abstract conflict graph (ACFG) \label{fig:filter}}
\end{minipage}
&
\begin{minipage}{4.40cm}
\centering
\vspace*{0.3cm}
\scalebox{.45}{\import{figures/}{acdl_run.pspdftex}}
%\caption{A control flow graph for P, P' and abstract conflict graph (ACFG) \label{fig:filter}}
\end{minipage}
\\
\hline
\end{tabular}
\caption{C Program, Control-flow Graph (CFG) and Abstract Conflict
  Graph \pscmt{where is the relational domain?}}
\label{example}
\end{figure}
Let us consider a simple program in Figure~\ref{example} that checks 
the equivalence of a state-machine based interger multiplication against  
a specification that uses multiplication operator (*).  The assertion 
simply compares the result of two multiplication for an integer input $x$.  
To avoid overflow error, we assume $x$ has an upper bound $N$.  The 
control flow graph is shown in the middle column of Figure~\ref{example}.  

We analyze the program using three different analyzers -- {\em bounded 
model checking (BMC)}, {\em abstract interpretation} and {\em ACDCL}.    
For $N=2$ and unwind limit of $bound=4$ for the {\em while} loop,
table~\ref{solver} shows the statistics from MiniSAT~\cite{minisat} solver 
for analysis using BMC.  The SAT solver makes 36 decisions, 1365 boolean 
constraint propagations and performs 5 conflict analysis with 65 conflict 
literals.  Moreover, the solver performs a restart, presumably to recover 
from bad decisions.  

On the other hand, abstract interpretation using forward analysis 
is too imprecise to verify the safety of the above program using 
interval domain.  The imprecision is due to control-flow join at 
node $n1$.  State-of-the-art abstract interpretation tool, Astr{\'e}e, 
requires external hints, provided by manually annotating the code 
with partition directives at $n1$, to prove safety.  The partition 
directive helps the tool to analyze each program execution paths 
separately.  To do so, Astr{\'e}e requires a product of trace 
partitioning domain and an interval domain to determine safety.  
Consequently, the analysis becomes very expensive for a large value 
of $N$.  In general, the imprecision is either intended by the tool 
because such high precision analysis is normally not required for 
runtime error analysis or the imprecision is unavoidable due to the 
complexity of the application under analysis.  
%
\begin{table}
\begin{center}
{
\begin{tabular}{l|l|l|l|l|l}
\hline
Solver & Decisions & propagations & conflict & conflict literals & restarts \\ \hline
SAT & 36 & 1365 & 5 & 65 & 1 \\ \hline
ACDCL & 1 & 23 & 1 & 1 & 0 \\
\hline
\end{tabular}
}
\end{center}
\caption{Solver-statistics}
\label{solver}
\end{table}
%
The right-side of Figure~\ref{example} shows an analysis using ACDCL with 
interval domain.  The analysis associates an interval for each control 
location and variable, as shown in the abstract conflict graph.  Interval 
constraints generated from forward analysis in the initial deduction phase 
infers that $\langle x:[-\infty,2], spec:[2,4], impl:[-1,\infty],
state:[1,\infty], y:[1,+\infty] \rangle$.  Clearly, ACDCL can not prove safety.  

Hence, ACDCL makes a decision $x:[-\infty,1]$ to refine the analysis.  
The branching variable $x$ is chosen by an {\em ordered} decision 
heuristics that choose variables appearing in conditional branches 
(assume statement here) first before choosing other program variables. 
The decision constrains the interval of $x$.  The deductions made 
during fixed point iteration are represented by abstract conflict 
graph in right-side of figure~\ref{example}.  Nodes in the graph 
denotes the corresponding updates to the program variables in 
the CFG.  Interval analysis concludes that the $(n12:\bot)$, that 
is the decision $x:[-\infty,1]$ leads to a {\em conflict}.  Thus, 
the program is {\em safe} for $x:[-\infty,1]$.  

A clause learning SAT solver would learn the reason for conflict at this 
point and then backtrack to a level such that the learnt clause is UNIT.  
Similar to conflict analysis phase in SAT solvers, ACDCL learns that 
(\(I: x = [2,+\infty]\)), that is all error traces must satisfy $(x \geq 2)$ 
at node $I$.  The analysis discards all interval constraints that
lead to the conflict and backtrack to decision level 0.  ACDCL then 
performs interval analysis with the learnt constraint $(x>=2)$ which again 
leads to a conflict.  The analysis cannot backtrack further and therefore 
it terminates proving that the program is safe.  A DPLL-style solver would 
perform proof by cases.  However, decision and clause learning are used 
to avoid case based reasoning and prevents enumeration behavior.     
   
The result of the analysis using ACDCL is shown in table~\ref{solver}.  
Compared to a SAT solver, ACDCL makes only a single decision which lead 
to 23 interval constraint propagations, and learns a single conflict clause 
involving only one literal.  Compared to abstract interpretation, ACDCL does 
not require external hints to proof the program, thus automatically performing 
program and property driven trace partitioning to generate proofs using decision 
and clause learning.  
