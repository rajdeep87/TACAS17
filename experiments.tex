\section{Experimental Results}
We have implemented the instantiation of ACDCL on relational domains
in 2LS verification tool~\cite{2ls}.  We have used the abstract domains
provided by 2LS (intervals, octagons, polyhedra and equalities) for our
experiments. Although the performance of the abstract domain implementations 
in 2LS is not competitive with that of APRON~\cite{apron} library, but 
the domain implementation in 2LS can handle all C operators 
(including bitwise operations) out of the box and support precise
complementation of meet irreducibles, which are necessary for our algorithm. 

We verified a total of 70 benchmarks in ANSI-C, which are derived from 
(a) bit-vector regression category in SV-COMP'16, (c) bit-precise and 
cycle accurate software models of hardware circuits automatically 
generated using v2c~\cite{mtk2016}, (c) controller code generated 
from Simulink (d) several hand-crafted benchmarks for equivalence 
checking and bounded loop analysis.  All benchmarks containing 
bounded loops are completely unrolled before analysis.  We compare 
our tool with a state-of-the-art SAT-based bounded model checker 
CBMC~\cite{cbmc} and a commercial static analysis tool, Astr{\'e}e.  
CBMC uses MiniSAT solver in the backend.  Astr{\'e}e was configured with 
default set of domains which includes interval, bit-field, congurence and 
relational domains.  Additionally, to enable precise analysis using 
Astr{\'e}e, we also used trace-partition domain.   

\Omit {
To enable precise analysis using Astr{\'e}e, all our benchmarks are 
manually instrumented with partition directives which provides external 
hint to the tool to guide the trace partitioning heuristics.  Usually, 
such high-precision is not needed for static analysis, since it makes 
the analysis very expensive.  Without trace partitioning, the 
analysis using Astr{\'e}e shows high degree of imprecision. 
}
\paragraph {\em \textbf{Observation of Analysis}}

\paragraph {\em \textbf{Decision Heuristics}} We compare the performance of 
different decision heuristic on our benchmarks.  We observe that 
the ordered heuristic outperforms other heuristics on control-intensive 
benchmarks due to its ability to prioritize decisions on variables that 
appears in conditional branches.  For straight-line code and most of 
the bit-vector regression suite, random heuristics performs the best.  
Whereas, the activity based heuristics such as Berkmin heuristic which 
works well in propositional cases performs best for benchmarks that 
encountered the maximum number of conflicts to prove safety, thus allowing 
the heuristics to choose the decison variable among the set of learnt clauses.   

\paragraph {\em \textbf{Propagation Strategy}}      

\paragraph {\em \textbf{Clause Learning}}      

%================  
\input{graphs}
%================  
