\section{Introduction}\label{introduction}
%
The conflict driven clause learning algorithm can be seen as an 
alternation between over-approximate deduction with boolean 
constraint propagation, and under-approximate abduction, with 
conflict analysis. The work of~\cite{dhk2013-popl,sas12,tacas12} 
shows that satisfiability solvers are static analyzers. They present 
a framework that strictly generalizes CDCL algorithm to lattices and 
abstract transformers. \\
Our work is fundamentally based on the work of~\cite{dhk2013-popl}. 
However, we extend the framework to use it as a backend reasoning 
engine for high-level reasoning of hardwares circuits represented as programs.
To this end, we treat programs as a logical formula. Give a programs $P$ and a trace $\pi$,
$\pi \models P$ iff trace $\pi$ is an erroneous trace generated by program
$P$. CDCL algorithm has two main phases which feedback information to each other --
{\em model search} and {\em conflict analysis}. The model search procedure tries to find a 
satisfying assignment to the input formula. If the search fails, meaning that the current 
partial assignment leads to a {\em conflict}, then the conflict analysis phase learns the 
reason for such failure to block the model search from entering into same conflicting 
search-space in future. More formally, given a set of formula $Form$ and a set of 
structure $Struct$, a semantic entailment relation is given as, $\models \in \mathcal{P}(Struct
\times Form)$, which specifies which structure satisfies which formula. A 
concrete domain is the power set of structures which gives us lattice. 
We define two transformers for a CDCL solver. \\
\textit{Model Transformer (mod):} Given a set of structure $S$, return all structures 
in $S$ that satisfy a formula $\varphi$. This is formally shows as follows:
$mod_{\varphi}(S) = \{\sigma | \sigma \in S \wedge \sigma \models \varphi\}$ \\

\textit{Conflict Transformer (conf):} Start with a set $S$, and add to $S$ all structures 
that contradict a formula $\varphi$. This is formally shows as follows:
$conf_{\varphi}(S) = \{\sigma | \sigma \in S \vee \sigma \not\models \varphi\}$
\\
We now define abstract interpretation analogues to model search and conflict analysis.   \\
\textit{Abstract Model Transformer (amod):} Given a program P, $amod$ gives the 
set of traces generated by the program and is erroneous. This can be
characterised in two different ways. We can start with the initial state and
compute least fix-point with strongest post-condition or start from error state 
and compute the greatest fix-point with weakest pre-condition. \\

\textit{Abstract Conflict Transformer (aconf):} Given a program P, $aconf$ gives the 
set of program traces that are safe, that is, all program traces that are not
generated by the program. \\

\textit{Interaction between amod and aconf:} If the search for finding an 
erroneous trace $(amod)$ fails, we get partial safety proofs which correspond 
to conflict in SAT solver. From the conflict collection transformer $(aconf)$ or 
proof stage, we get back refinement of strongest post-condition which keeps in 
mind satisfiability information. 

Most lattice structure used in static analysis have meet and join operations 
but lack negations. The meet operation precisely model conjunction, and
the join operation over-approximate disjunction. Thus, the precision loss in 
static analyzers is often due to imprecise join operations. The loss in precision is
overcome by using richer abstract domains or equipping the analysis with disjunction --
which is often very expensive since the analysis exhibit case enumeration behavior. 
 
On the other hand, the combination of precise conjunction in partial assignments domain 
with learning allow CDCL solvers to reason about disjunction without 
enumerating cases. Learning can be viewed as synthesizing an abstract transformer for 
negation. ACDCL lifts learning techniques in SAT solver to operate on non-distributive 
lattice -- thus equipping the analysis with negation. This enables the analyzer to refine 
the analysis and prevent enumeration behavior.
