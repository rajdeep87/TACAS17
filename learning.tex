\section{Abstract Conflict Analysis}
A conflict analysis in a SAT solver can be seen as abductive 
reasoning where a singleton assignment $c$ is replaced by a partial 
assignment that is sufficient to infer $c$.  Thus, a conflict 
analysis is a generalization of an underapproximation of a set of 
countermodels~\cite{sas12,dhk2013-popl}, where a countermodel is a 
set of structures that do not satisfy a formula.  Since relational 
abstract domains have more complex structure than a partial 
assignments domain, so the lifting of {\em first-UIP} algorithm~\cite{uip} 
and clause learning to any arbitraty lattice structure is a non-trivial task. 

\paragraph {\textbf{Abstract Conflict Graph}}
The first-UIP algorithm in SAT solver works on a data structure called 
{\em implication graph} that computes a cut that suffices to produce a 
conflict.  The trail in ACDCL implicitly encodes a graph structure called 
{\em abstract conflict graph}, which records the dependencies between 
deductions made during abstract model search phase.  Nodes in the graph 
represent elements of the trail $\mathcal{T}$.  Nodes can be either 
{\em decision} node or {\em deduction} node. Edges can be extracted from
the transformers in the reason trail.  Incoming arrows to node $n$ 
indicate that the predecessors of $n$ are sufficient to deduce $n$.  
A decision node has no incoming edges.  
For example, consider a formula 
$\varphi:= (x=5 \wedge y=x \wedge y=y+x \wedge y \leq 0)$ with current 
abstract valuation $v:= (x=5)$.  Figure~\ref{conflict} shows a 
snapshot of an abstract conflict graph that 
stores the deductions obtained from abstract model search using octagon domain.  
The last deduction conflict with the constraint $(y \leq 0)$.  

\paragraph {\textbf{Lifting UIP to relational domains}}
An UIP is a special node in the abstract conflict graph such that 
any path from the last decision node to the conflict node must pass 
through it.  Unlike a SAT solver, a UIP in ACDCL may involve meet irreducibles 
that involves the same variables.  The first-UIP is a node closest to the 
conflict, and the last UIP is the decision node itself.  Computing UIPs ensures 
asserting cuts, that is, it yields clauses that generates new deduction after 
backtracking.  Every cut in the graph reason for conflict that can be used in learning.  
A first-UIP algorithm traverses the trail $\mathcal{T}$ starting from the 
conflict node and iteratively finds new nodes that contradict with the 
transformer stored in $reasons[\bot]$.  

For our example, there exists multiple incomaparable reasons for conflict,
marked as {\em cut0, cut1}, in figure~\ref{conflict}.  Here, cut0 is the first UIP.  
Choosing cut0 yields a learnt clause 
$L_0: (x+y<15 \vee -x-y<-15 \vee -x+y<5 \vee x-y<-5 \vee y-10<0 \vee -y+10<0)$.  
%
\begin{figure}
%\caption{An example of Octagon}\label{octagon}
\scalebox{.65}{\import{figures/}{conflict_graph.pspdftex}}
\label{conflict}
\end{figure} 
%    
\paragraph{\textbf{Clause Learning in Abstract Lattice}}
A learnt clause $\mathcal{L}$ in propositional solver is obtained 
by negating the reason for conflict.  An asserting clause guarantees 
new dductions using unit rule~\cite{cdcl}.  However, we model a 
learnt clause as abstract deduction transformer, called {\em abstract unit 
transformer (AUnit)}.  For an abstract lattice $A$ and a set of 
countermodels $C \subseteq A$ of $\varphi$ such that \meet{C} does not 
satisfy $\varphi$, $AUnit_C: A \rightarrow A$ is $\top$ if $\exists a \in A$ 
such that $a \subseteq \meet{C}$.  However, if $t \in C$ and 
$\forall t' \in C \ {t}$ such that $a \sqsubseteq t'$, $AUnit$ 
infers a valid deduction $\bar{t}$, which directs the search 
away from the conflict region. Else, $AUnit$ returns $\top$.   

\paragraph {\textbf{Backjumping}}
A backjumping procedure undo all the assignments in the trail up to 
a decision level that restores the solver to a consistent state 
(non-conflicting).  The backjumping level is defined by the literal 
of the conflict clause that is closest to the root (decision level 0) 
where the conflict clause is still unit. If a conflict clause is 
globally unit, then the backjumping level is the root of the search tree.

The abstract clause learning and backjumping procedures in the abstract 
conflict graph is stated in terms of the state of ACDCL solver as follows. 
\[AbsLearn: \quad  (\mathcal{E},S) \rightarrow (\mathcal{E},S \wedge
\mathcal{L}) \quad \text{if} \; \mathcal{L} \notin S \; \textrm{and}
\; (S \wedge \mathcal{L}) \; \text{is not UNSAT} \]
\[AbsBackjump: \quad (\mathcal{E}_1(m,s)\mathcal{E}_2,S) \rightarrow
(\mathcal{E}_1,S) \quad \text{if} \; (\mathcal{E}_1,S) \; \text{is
consistent} \]   


\Omit {
\subsection{Clause Learning in Abstract Lattice}
Conflict graph for Intervals
Conflict graph for Octagons

\textit{Characteristics of Conflict clause}
\begin{enumerate}
\item A conflict clause must include asserting cuts. An asserting cut is a cut
that contain exactly one node at the current decision level. Assertion cuts yields 
clauses that can be used to derive new information after backtracking.

\item A conflict clause must be UNIT after backtracking. 

\item There can be multiple cuts and hence multiple UIPs. In other words, there
can be multiple incomparable reasons for a conflict. But conflict analysis
procedure choses one that is asserting. 

\item The conflict clause should be made false by the current partial assignment
and thus exclude an assignment leading to conflict. 
\end{enumerate}

1.DPLL style -- chronological backtracking \\
2. CDCL style -- non-chronological backtracking \\
  a. first-uip \\
  b. last-uip \\

**********************************************
\subsection{Lifting First UIP to Octagon domain}
**********************************************
unit-ness guarantee in octagon domain:
  Popped stmt: y23=1+y21
   Abstract value:
   D1: y23-y21 < 2 &&
   D2: y23+y21 > 0 &&
   D3: y21 < 1
   After backtracking, apply unit rule 
   y23 > 1 -- deduction from unit rule
   Value inconsistent !!
 
 Note: 
 1> cannot make reasoning at literal level for relational domain because literals are dependant on each other. As soon as literals denote relation between first-order variables, the pure reasoning on boolean skeleton is not sufficient. 
 
2> Intervals are orthogonal half spaces similar to booleans. 

3> After backtracking, the application of unit rule is done as follows for relational domains:
  Pass the learnt clause (as statement) and the abstrat value to the domain to make deductions.
}
