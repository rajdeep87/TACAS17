\documentclass[a4paper,conference]{llncs}

\usepackage{import}
\usepackage{times}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathptm}
%\usepackage{rotating}
\usepackage{color}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{comment}
\usepackage{alltt}
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{epsfig}
\usepackage{wasysym} 
\usepackage{subfigure}
\usepackage{paralist}
%\usepackage{mdwlist}
%\usepackage{multirow}
\usepackage{dingbat}
% \usepackage{hyperref}
%\usepackage{colortbl}
%\usepackage{booktabs}
\usepackage[algo2e,linesnumbered,ruled,lined]{algorithm2e}
\usepackage{hyperref}
%\usepackage{dcolumn}
%\newcolumntype{"}{@{\hskip\tabcolsep\vrule width 1pt\hskip\tabcolsep}}
\makeatother

\newcommand{\tool}[1]{\textsc{#1}\xspace}
\newcommand{\symex}{\tool{path-symex}}
\newcommand{\cbmcv}{\tool{cbmc 5.0}}
\newcommand{\Omit}[1]{}

\input{symbols}

\begin{document}

%\title{Equipping Abstact Conflict Driven Clause Learning \\ Solver with Relational Domains}
\title{Automated Reasoning of Relational properties using \\
Abstact Conflict Driven Clause Learning}
\maketitle
\begin{abstract}
%
{\em Abstract Conflict Driven Clause Learning} (ACDCL) is a novel program analysis that embeds an 
abstract domain inside the Conflict Driven Clause Learning (CDCL) algorithm. From decision procedure 
perspective, ACDCL is a SAT solver for program analysis constraints and is a strict generalisation of 
propositional CDCL solvers. From Abstract Interpretation point of view, ACDCL can be viewed as an 
abstract interpreter that uses decision and learning to increase the precision of abstract transformers. 
In this paper, we present a technique to generalize ACDCL solvers to reason about relational properties 
of a program by embedding relational domains like octagon domain inside the ACDCL solver.  Experimental 
evidence shows significantly less number of decisions and learning iterations required by ACDCL solver to 
prove programs with relational properties compared to bit-blasting and applying propositional SAT solvers -- 
thereby emphasizing the need for abstract reasoning using ACDCL. 
%
\end{abstract}

\section{Introduction}


\section{Lifting CDCL to Programs}
The conflict driven clause learning algorithm can be seen as an 
alternation between over-approximate deduction with boolean 
constraint propagation, and under-approximate abduction, with 
conflict analysis. The work of~\cite{dhk2013-popl,sas12,tacas12} 
shows that satisfiability solvers are static analyzers. They present 
a framework that strictly generalizes CDCL algorithm to lattices and 
abstract transformers. \\
Our work is fundamentally based on the work of~\cite{dhk2013-popl}. 
However, we extend the framework to use it as a backend reasoning 
engine for high-level reasoning of hardwares circuits represented as programs.
To this end, we treat programs as a logical formula. Give a programs $P$ and a trace $\pi$,
$\pi \models P$ iff trace $\pi$ is an erroneous trace generated by program
$P$. CDCL algorithm has two main phases which feedback information to each other --
{\em model search} and {\em conflict analysis}. The model search procedure tries to find a 
satisfying assignment to the input formula. If the search fails, meaning that the current 
partial assignment leads to a {\em conflict}, then the conflict analysis phase learns the 
reason for such failure to block the model search from entering into same conflicting 
search-space in future. More formally, given a set of formula $Form$ and a set of 
structure $Struct$, a semantic entailment relation is given as, $\models \in \mathcal{P}(Struct
\times Form)$, which specifies which structure satisfies which formula. A 
concrete domain is the power set of structures which gives us lattice. 
We define two transformers for a CDCL solver. \\
\textit{Model Transformer (mod):} Given a set of structure $S$, return all structures 
in $S$ that satisfy a formula $\varphi$. This is formally shows as follows:
$mod_{\varphi}(S) = \{\sigma | \sigma \in S \wedge \sigma \models \varphi\}$ \\

\textit{Conflict Transformer (conf):} Start with a set $S$, and add to $S$ all structures 
that contradict a formula $\varphi$. This is formally shows as follows:
$conf_{\varphi}(S) = \{\sigma | \sigma \in S \vee \sigma \not\models \varphi\}$
\\
We now define abstract interpretation analogues to model search and conflict analysis.   \\
\textit{Abstract Model Transformer (amod):} Given a program P, $amod$ gives the 
set of traces generated by the program and is erroneous. This can be
characterised in two different ways. We can start with the initial state and
compute least fix-point with strongest post-condition or start from error state 
and compute the greatest fix-point with weakest pre-condition. \\

\textit{Abstract Conflict Transformer (aconf):} Given a program P, $aconf$ gives the 
set of program traces that are safe, that is, all program traces that are not
generated by the program. \\

\textit{Interaction between amod and aconf:} If the search for finding an 
erroneous trace $(amod)$ fails, we get partial safety proofs which correspond 
to conflict in SAT solver. From the conflict collection transformer $(aconf)$ or 
proof stage, we get back refinement of strongest post-condition which keeps in 
mind satisfiability information. 

Most lattice structure used in static analysis have meet and join operations 
but lack negations. The meet operation precisely model conjunction, and
the join operation over-approximate disjunction. Thus, the precision loss in 
static analyzers is often due to imprecise join operations. The loss in precision is
overcome by using richer abstract domains or equipping the analysis with disjunction --
which is often very expensive since the analysis exhibit case enumeration behavior. 
 
On the other hand, the combination of precise conjunction in partial assignments domain 
with learning allow CDCL solvers to reason about disjunction without 
enumerating cases. Learning can be viewed as synthesizing an abstract transformer for 
negation. ACDCL lifts learning techniques in SAT solver to operate on non-distributive 
lattice -- thus equipping the analysis with negation. This enables the analyzer to refine 
the analysis and prevent enumeration behavior. 

\section{Definitions}
\textit{Literal:} A Literal is a meet irreducible which are minimum complementable
elements which specify that for certain program variable, there is a certain
bound. An example of literal is $x \leq 0$.

Let us define the notion of literals with respect to interval domain. 
An interval $([l:u])$ is defined by a lower bound $(l)$ and an upper bound $(u)$.
Let I and J be two intervals. The relation between I and J is defined as follows:\\
We say $I \leq J$ or {\em (I leq J)} if $(I.u \leq J.u \wedge I.l \geq J.l)$\\
We say {\em I disjoint J} if $(I.u < J.l \vee  I.l > J.u)$.

Let $x$, $x'$ be the intervals of a variable $p$ in current 
partial assignment and the current clause respectively. 
We define a literal and a clause to be satisfiable or unsatisfiable 
or contradicting with respect to an interval abstraction as follows. \\
\textit{Satisfiable literal:} 
We say $x'$ is satisfiable literal if $(x \leq x')$.

\textit{Unsatisfiable literal:}
We say $x'$ is satisfiable literal if $!(x \leq x') \wedge$ $!$(x disjoint $x'$).

\textit{Contradicting Literal:}
We say $x'$ is contradicting literal if $!(x \leq x') \wedge$ (x disjoint $x'$).

\textit{Clause:} A clause is a disjunction of one or more meet irreducibles. An 
example clause is $(x \geq 0 \vee y \geq 5 \vee y \leq 10 \vee y \leq 7)$.

\textit{Satisfiable clause:}
If at least one meet irreducible in a clause is satisfiable, then a clause is said to 
be satisfiable. For example, consider a clause $C=(x<4 \vee y>10)$. Let the 
current partial assignment be $x \in [0,3]$, then $C$ is a satisfiable clause. 

\textit{Conflicting clause:}
If all the meet irreducibles in a clause are contradicting, then the clause is said to
be conflicting. For example, consider a clause $C=(x<4 \vee y>10 \vee z<15)$. Let the 
current partial assignment be $x \in [5,13]$ and $y \in [-2,9]$ and $z \in
[17,32]$, then $C$ is a conflicting clause.

\textit{Unsatisfiable clause:}
If no meet irreducibles in a clause are satisfiable or some meet
irreducibles are not satisfiable and the rest are contradicting, we call a 
clause unsatisfiable. For example, consider a clause $C=(x<4 \vee y>10 \vee z<15)$. 
Let the current partial assignment be $x \in [3,10]$, $y \in [8,10]$ and $z \in [12,20]$, 
then $C$ is a unsatisfiable clause. 

\textit{Unit clause:}
If all meet irreducible but one is contradicting in a clause, we call the clause
to be unit. For example, consider a clause $C=(x<4 \vee y>10 \vee z<15)$. Let the 
current partial assignment be $x \in [5,13]$ and $y \in [-2,9]$ and $z \in
[10,12]$, then $C$ is a unit clause where the unit literal is $z$. 

\textit{Unit Rule:} A unit rule is the best abstract transformer 
(strongest post-condition or weakest pre-condition). 

\textit{Boolean constraint propagation (BCP):} BCP is the repeated 
application of unit rule. This corresponds to computing the greatest fixed point.

\textit{Characteristics of Conflict clause}
\begin{enumerate}
\item A conflict clause must include asserting cuts. An asserting cut is a cut
that contain exactly one node at the current decision level. Assertion cuts yields 
clauses that can be used to derive new information after backtracking.

\item A conflict clause must be UNIT after backtracking. 

%\item There can be multiple cuts and hence multiple UIPs. In other words, there
%can be multiple incomparable reasons for a conflict. But conflict analysis
%procedure choses one that is asserting. 

%\item The conflict clause should be made false by the current partial assignment
%and thus exclude an assignment leading to conflict. 
\end{enumerate}

\textit{Backjumping:}
The backjumping level is defined by the literal of the conflict clause assigned
at the level that is the closest to the conflict one. In other words, the
backjumping level is the level closest to the root (decision level 0)  where the
conflict clause is still unit. If a conflict clause is "globally"  unit, then
the backjumping level is the root of the search tree.

\section{Abstract Conflict Driven Clause Learning}
\begin{algorithm2e}[t]
\DontPrintSemicolon
\SetKwFunction{decide}{Decide}
\SetKwFunction{deduce}{deduce}
\SetKwFunction{backtrack}{backtrack}
\SetKwFunction{print}{print}
\SetKwFunction{return}{return}
\SetKwFunction{nondet}{nondet}
\SetKwFunction{run}{run}
\SetKwFunction{learn}{learn}
\SetKwFunction{continue}{continue}
\SetKwFunction{assign}{assign}
\SetKwRepeat{Do}{do}{while}
%\SetKwFunction{assume}{assume}
%\SetKwFunction{isf}{isFeasible}
\SetKwData{safe}{safe}
\SetKwData{unsafe}{unsafe}
\SetKwData{unknown}{unknown}
\SetKwData{true}{true}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKw{KwNot}{not}
\begin{small}
\Input{Program $\mathcal{P}$ with properties specified with $assert(c)$}
\Output{The status (\safe or \unsafe) and a counterexample if \unsafe}
\assign result=\deduce(P)\;
\uIf{$result == \perp$} {
  \return \safe \;
}
\uElse
{
  \uIf{is\_gamma\_complete()} {
    \return \unsafe \;
  }
}
\While{$true$} 
{
  \assign decision\_variable = decision\_heuristics($P$)\;
  %\assign decision\_container = decision\_container $\cup$ decision\_variable\; 
  \uIf{decision\_variable == NULL}
  {
    return \unknown\; 
  }
  \uElse
  {
    \assign result=\deduce(P)\;
    \uIf{result == UNKNOWN}
    {
      \uIf{is\_gamma\_complete()} {
        \return \unsafe \;
      }
      \uElse 
      {
        \continue\;
      }
    }
    \uElse
    {
      \Do{$result == \perp$} {
        \uIf{$\neg$ conflict\_analysis()} {
          return \safe \;  
        }
        \assign result=\deduce(P)\;
      }
    }
  }
}
\end{small}
\caption{Abstract Conflict Driven Clause Learning\label{Alg:acdcl}}
\end{algorithm2e}
%
Static program analysis based on abstract
interpretation~\cite{DBLP:conf/emsoft/Cousot07} has been widely used to
verify certain classes of properties for safety-critical systems.  In
abstract interpretation, a given program is analysed with respect to a set
of given abstract domains.  However, ACDCL is a novel program analysis 
technique that embeds an abstract domain inside the CDCL algorithm.
From the abstract interpretation point of view, ACDCL is an abstract 
interpreter that uses decision and learning to increase transformer precision. 
From the decision procedure perspective, ACDCL is a SAT solver for program 
analysis constraints and is thus a strict generalisation of propositional CDCL solvers.
Constraint propagation in ACDCL uses fixed point iteration, decisions restrict the 
range of intervals and learning generates program analysis constraints (not assumptions) 
that preserve the error reachability.  Moreover, ACDCL implicitly 
perform program and property driven trace partitioning to increase the precision
of the analysis.  
\Omit{
We observe that the abstract domains necessary for 
hardware property checking are -- booleans, constants, interval, equality 
and octagons domains.
}

Algorithm~\ref{Alg:acdcl} presents an overview of the ACDCL algorithm.
Given a program $\mathcal{P}$ with properties specified as $assert(c)$,
ACDCL terminate with {\em safe} if there exist no counterexample trace violating the 
assertion or {\em unsafe} otherwise. The procedure $deduce(P)$ is similar 
to BCP step in SAT solvers where it computes least fix-point with 
strongest post-condition using forward analysis. If the result of $deduce(P)$ 
is BOTTOM ($\perp$), the algorithm terminates with {\em safe}. Else, the 
{\em gamma completeness} check~\cite{sas01} is performed to determine if it is a 
real counterexample. If the {\em gamma completeness} check is successful, then the 
counterexample is real. Else, the algorithm enters into the while($true$)
loop and heuristically picks a meet irreducible for decision. For example, assuming 
interval domain, decisions restrict the range of intervals for variables, so the analysis jumps under a 
greatest fixed-point. Note that the widening operation in abstract interpretation 
jumps above a least fixed-point, so decisions can be viewed as 
dual widening. The procedure $deduce(P)$ is called next to deduce new facts for 
current decision. The algorithm terminates with {\em unsafe} if the result of $deduce(P)$ 
is {\em gamma complete}. Else, the algorithm enters in to $conflict\_analysis()$ phase to learn 
the reason for {\em conflict}. There can be multiple incomparable reasons for conflict --
based on the choice of Unique Implication Point (UIP), ACDCL heuristically choose one. 
A learnt clause must include asserting cuts which guarantees
derivation of new information after backtracking. The clause learning and backtracking continues 
as long as the result of deduction is BOTTOM ($\perp$) or the 
analysis backtracks to decision level 0. If no further backtrack is possible, then the 
algorithm terminates with {\em safe}. Else, the algorithm makes a new decision and 
the above process is repeated until a real counterexample is obtained or the algorithm 
backtracks to decision level 0 after a conflict in which case it returns {\em safe}. 
Currently, ACDCL handles loops in the program by unrolling the bounded loops. 
However, we are developing a new technique for automatic invariant generation using 
ACDCL for unbounded proofs. 

%
\subsection{Example Demonstrating Working of ACDCL}
\begin{figure}[htp]
\centering
\vspace*{0.3cm}
\scalebox{.45}{\import{figures/}{cfg-conflict.pspdftex}}
\caption{A control flow graph for P, P' and abstract conflict graph (ACFG) \label{fig:filter}}
\end{figure}


\lstdefinestyle{mystyle}{
    numbers=left,                    
    numbersep=5pt,                  
    tabsize=2,
    mathescape=true,
    language=C
}
\lstset{style=mystyle}
%\vspace{-2mm}
Let us consider a simple safe program $P$ as shown in Figure~\ref{fig:filter}A.
Astr{\'e}e fails to verify the safety using interval and trace-partition domain
due to control-flow join at location $n5$.  Astr{\'e}e requires external hints, provided by 
manually annotating the code with partition directives at $n1$, to prove safety.  
In general, the imprecision is either intended by the tool because such high precision analysis is 
normally not required for runtime error analysis or the imprecision is unavoidable 
due to the complexity of the application under analysis.

On the other hand, ACDCL uses decision and learning to generate the proof 
using simple interval domain. The analysis associates an interval with each location and variable.  
Assuming $bool: c = [0,1]$, ACDCL performs backward propagation 
starting from $n6$ by computing the weakest precondition for every statement 
in $P$ and immediately infers that (\(n4: x = \bot)\), thus proving safety as shown in 
red color in figure~\ref{fig:filter}A.  Now, let us consider program $P'$ in
Figure~\ref{fig:filter}B. Assuming $char: c$, ACDCL performs both forward and
backward propagations (shown in red color in Figure~\ref{fig:filter}B).  
The analysis then perform sequence of decisions starting with $c = [0,255]$ and reaches a 
conflict when the decision is (\(n1:c == [0,0]\)) which is connected to $(n6: \bot)$ 
and suffices to prove safety.  The deductions made during fixed point
iteration are represented by abstract conflict graph shown in Figure~\ref{fig:filter}C. 
Similar to conflict analysis phase in SAT solvers, ACDCL learns (\(n1: c = [1,255]\)), 
that is all error traces must satisfy (\(c \neq 0\)) at n1.  The analysis backtracks 
discarding all assumptions. Interval analysis is run with the learnt constraint and 
can prove safety.  Thus, decisions and clause learning are used to avoid case based reasoning. 
The advantage of ACDCL over propositional SAT solver is that the decision heuristics in 
ACDCL can exploit the program structure by making decisions on interesting program 
variables (for example variables in conditional branches or loop variables). Experimental 
evidence shows that this leads to significantly less number of decisions compared 
to the propositional solver. Compared to classical abstract interpretation 
based tools, ACDCL automatically performs program and property driven trace partitioning 
using decision and clause learning to generate proofs using simpler domain -- thus, it is more 
precise than classical abstract interpretation.   

\section{Deduction Phase}
Overapproximating.
\subsection{Forward analysis with strongest post-condition}
\subsection{Chaotic iteration strategy} 
\section{Decision Heuristics}
Berkmin, longest-range, random, ordered, octagons 
\section{Abstract Domains}
Support for Interval, Octagons
\section{Clause Learning}
1.DPLL style -- chronological backtracking \\
2. CDCL style -- non-chronological backtracking \\
  a. first-uip \\
  b. last-uip \\

\bibliographystyle{splncs03}
\bibliography{biblio.bib}

\end{document}
